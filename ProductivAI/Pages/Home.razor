@layout EmptyLayout
@page "/"
@using Markdig
@using ProductivAI.Application.Services
@using ProductivAI.Components
@using ProductivAI.Core.Models
@using ProductivAI.Core.Interfaces
@using ProductivAI.AIServices
@using Microsoft.JSInterop
@using System.Threading
@using System.Text.Json
@inject ITaskService TaskService
@inject ITaskRepository TaskRepository
@inject OpenRouterAIService AIService
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject IConversationService ConversationService

<div class="dashboard-container">
    <div class="dashboard-content">      
        <!-- Chat Panel - 60% width, no padding, aligned to top/left/bottom edges, no border -->
        <div class="chat-panel">            
            <div class="chat-messages bubble-chat" @ref="chatMessagesElement" @onscroll="HandleChatScroll">
                @if (!messages.Any())
                {
                        <div class="empty-chat">
                            <div class="empty-chat-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                            </div>
                            <h3 class="text-xl font-medium mb-2">AI Assistant</h3>
                            <p class="text-gray-500 text-center max-w-md mb-6">
                                Ask me anything about your tasks and notes, or how I can help you be more productive.
                            </p>
                            <div class="suggested-prompts">
                                <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("What tasks should I prioritize today?")'>
                                    What tasks should I prioritize today?
                                </button>
                                <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("Help me organize my notes on project planning.")'>
                                    Help me organize my notes on project planning.
                                </button>
                                <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("Create a weekly review template for me.")'>
                                    Create a weekly review template for me.
                                </button>
                            </div>
                        </div>
                }
                else
                {
                        <div class="messages-container">
                        @foreach (var message in messages)
                        {
                                    <div class="message-row @(message.IsFromUser ? "message-right" : "message-left")">
                                        <div class="avatar-container">
                                            <div class="avatar @(message.IsFromUser ? "user-avatar" : "ai-avatar")">
                                        @if (message.IsFromUser)
                                        {
                                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                                        }
                                        else
                                        {
                                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="9" x2="9" y2="21"></line><line x1="15" y1="9" x2="15" y2="21"></line></svg>
                                        }
                                            </div>
                                        </div>
                                        <div class="message-bubble">
                                    @if (!message.IsFromUser && message.HasReasoning)
                                    {
                                                    <div class="reasoning-container @(reasoningExpandedStates.ContainsKey(message) && reasoningExpandedStates[message] ? "expanded" : "collapsed")" style="width: 100%; flex-shrink: 0;">
                                                        <div class="reasoning-header" @onclick="() => ToggleMessageReasoningExpansion(message)">
                                                            <div class="reasoning-title">
                                                                <span>Reasoning</span>
                                                            </div>
                                                            <button class="expand-button">
                                                    @if (reasoningExpandedStates.ContainsKey(message) && reasoningExpandedStates[message])
                                                    {
                                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
                                                    }
                                                    else
                                                    {
                                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                                                    }
                                                            </button>
                                                        </div>
                                            @if (reasoningExpandedStates.ContainsKey(message) && reasoningExpandedStates[message])
                                            {
                                                                <div class="reasoning-content">
                                                    @((MarkupString)FormatMessageContent(message.ReasoningContent))
                                                                </div>
                                            }
                                                    </div>
                                    }
                                            <div class="message-content">
                                        @((MarkupString)FormatMessageContent(message.Content))
                                            </div>
                                        </div>
                                    </div>
                        }

                        @if (isStreaming)
                        {
                                    <div class="message-row message-left">
                                        <div class="avatar-container">
                                            <div class="avatar ai-avatar">
                                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="9" x2="9" y2="21"></line><line x1="15" y1="9" x2="15" y2="21"></line></svg>
                                            </div>
                                        </div>
                                        <div class="message-bubble">
                                    @if (useReasoning && !string.IsNullOrEmpty(currentReasoningContent))
                                    {
                                                    <div class="reasoning-container @(expandedReasoning ? "expanded" : "collapsed")" style="width: 100%; flex-shrink: 0;">
                                                        <div class="reasoning-header" @onclick="ToggleReasoningExpansion">
                                                            <div class="reasoning-title">
                                                                <span>Reasoning</span>
                                                    @if (!expandedReasoning)
                                                    {
                                                                        <div class="typing-indicator">
                                                                            <span></span>
                                                                            <span></span>
                                                                            <span></span>
                                                                        </div>
                                                    }
                                                            </div>
                                                            <button class="expand-button">
                                                    @if (expandedReasoning)
                                                    {
                                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
                                                    }
                                                    else
                                                    {
                                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                                                    }
                                                            </button>
                                                        </div>
                                            @if (expandedReasoning)
                                            {
                                                                <div class="reasoning-content">
                                                    @((MarkupString)FormatMessageContent(currentReasoningContent))
                                                                </div>
                                            }
                                                    </div>
                                    }
                                            <div class="message-content">
                                        @((MarkupString)FormatMessageContent(currentStreamedContent))
                                                <div class="typing-indicator">
                                                    <span></span>
                                                    <span></span>
                                                    <span></span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                        }
                        </div>
                }

                <!-- Add the floating scroll-to-bottom button -->
                <div class="scroll-bottom-button @(showScrollButton ? "visible" : "")" @onclick="ForceScrollToBottom">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
            </div>
            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <textarea 
                        @bind="currentMessage" 
                        @bind:event="oninput"
                        @onkeydown="HandleKeyDown"
                        @onfocus="async () => await DisableShortcutsAsync()"
                        @onblur="async () => await EnableShortcutsAsync()"
                        placeholder="Ask your AI assistant..."
                        class="chat-textarea"
                        rows="1"
                        disabled="@isStreaming"
                        @ref="textAreaRef">
                    </textarea>
                    <button 
                        class="send-button"
                        @onclick="SendMessageAsync"
                        disabled="@(string.IsNullOrWhiteSpace(currentMessage) || isStreaming)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>

                <div class="chat-options">
                    <!-- Model selection moved here -->
                    <div class="model-select">
                        <select class="select-input" @bind="selectedModel" disabled="@isStreaming">
                            <option value="qwen32b">Qwen 32B</option>
                        </select>
                    </div>

                    <!-- Changed to toggle switches -->
                    <div class="chat-option">
                        <label class="switch">
                            <input type="checkbox" @bind="useReasoning" disabled="@isStreaming" />
                            <span class="slider round"></span>
                        </label>
                        <span>Use reasoning</span>
                    </div>

                    <div class="chat-option">
                        <label class="switch">
                            <input type="checkbox" @bind="showReasoning" disabled="@(!useReasoning)" />
                            <span class="slider round"></span>
                        </label>
                        <span>Show reasoning</span>
                    </div>

                    <button class="btn-icon" @onclick="ClearChat" disabled="@isStreaming">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path></svg>
                    </button>
                    <button class="btn-icon" @onclick="EndAndArchiveConversation" disabled="@(isStreaming || isEndingConversation)">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        End & Archive
    </button>
                </div>
            </div>
        </div>

        <!-- Tasks Panel with padding -->
        <div class="tasks-panel">
    <div class="tasks-inner-container">
        <!-- Panel header -->
        <div class="panel-header">
    <h2>Tasks</h2>
    <div class="flex gap-2">
        <button class="btn-new-task" @onclick="ShowNewTaskModal" title="New Task">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
        <button class="btn-new-task" @onclick="ShowUserContextModal" title="Edit User Context">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
        </button>
        <select class="select-input" @bind="currentSortOption" @bind:after="SortTasksAsync">
            <option value="DueDate">Due Date</option>
            <option value="Priority">Priority</option>
            <option value="CreationDate">Creation Date</option>
        </select>
    </div>
</div>

            <div class="tasks-list">
                @if (loading)
                {
                        <div class="loading-spinner">
                            <div class="spinner"></div>
                            <span>Loading tasks...</span>
                        </div>
                }
                else if (tasks == null || !tasks.Any())
                {
                        <div class="empty-state">
                            <div class="empty-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                            </div>
                            <p>No tasks yet. Create your first task to get started.</p>
                        </div>
                }
                else
                {
                    @if (overdueTasks.Any())
                    {
                                <div class="task-group">
                                    <h4 class="text-red-600 font-medium">Overdue</h4>
                            @foreach (var task in overdueTasks)
                            {
                                            <TaskItemComponent Task="task" 
                                                            OnComplete="CompleteTaskAsync" 
                                                            OnEdit="EditTask" 
                                                            OnAddSubtask="ShowAddSubtaskModal" />
                            }
                                </div>
                    }

                        <div class="task-group">
                            <h4 class="font-medium">Tasks</h4>
                        @foreach (var task in regularTasks)
                        {
                                    <TaskItemComponent Task="task" 
                                                    OnComplete="CompleteTaskAsync" 
                                                    OnEdit="EditTask" 
                                                    OnAddSubtask="ShowAddSubtaskModal" />
                        }
                        </div>
                }
            </div>
        </div>
        </div>
    </div>

    @if (showNewTaskModal)
    {
        <div class="modal-backdrop"></div>
        <div class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>@(editingTask ? "Edit Task" : "New Task")</h3>
                    <button class="close-button" @onclick="HideModal">×</button>
                </div>
                <div class="modal-body">
                    <EditForm Model="newTask" OnValidSubmit="SaveTaskAsync">
                        <DataAnnotationsValidator />
                        <ValidationSummary />

                        <div class="form-group">
                            <label for="title">Title</label>
                            <InputText id="title" class="form-input" @bind-Value="newTask.Title" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                        </div>

                        <div class="form-group">
                            <label for="description">Description</label>
                            <InputTextArea id="description" class="form-textarea" @bind-Value="newTask.Description" rows="3" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                        </div>

                        <div class="form-row">
                            <div class="form-group half">
                                <label for="dueDate">Due Date</label>
                                <InputDate id="dueDate" class="form-input" @bind-Value="newTask.DueDate" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                            </div>
                            <div class="form-group half">
                                <label for="priority">Priority (1-5)</label>
                                <InputNumber id="priority" class="form-input" @bind-Value="newTask.Priority" min="1" max="5" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                            </div>
                        </div>

                        <div class="form-check">
                            <InputCheckbox id="isRecurring" @bind-Value="newTask.IsRecurring" />
                            <label for="isRecurring">Recurring Task</label>
                        </div>

                        @if (newTask.IsRecurring)
                        {
                                <div class="form-group">
                                    <label for="recurrencePattern">Recurrence Pattern</label>
                                    <InputSelect id="recurrencePattern" class="form-select" @bind-Value="newTask.RecurrencePattern">
                                        <option value="daily">Daily</option>
                                        <option value="weekly">Weekly</option>
                                        <option value="monthly">Monthly</option>
                                        <option value="yearly">Yearly</option>
                                        <option value="every 2 days">Every 2 Days</option>
                                        <option value="every 2 weeks">Every 2 Weeks</option>
                                    </InputSelect>
                                </div>
                        }

                        <!-- Subtasks Section -->
                        @if (editingTask)
                        {
                                <div class="subtasks-section">
                                    <div class="section-header">
                                        <h4>Subtasks</h4>
                                    </div>

                                @if (newTask.SubTasks.Any())
                                {
                                            <div class="subtasks-list">
                                        @foreach (var subtask in newTask.SubTasks)
                                        {
                                                        <div class="subtask-item">
                                                            <div class="subtask-checkbox">
                                                                <input type="checkbox" checked="@subtask.IsCompleted" @onchange="e => subtask.IsCompleted = (bool)e.Value" />
                                                            </div>
                                                            <div class="subtask-content">
                                                    @subtask.Description
                                                            </div>
                                                            <button type="button" class="subtask-remove" @onclick="() => RemoveSubtask(subtask)">×</button>
                                                        </div>
                                        }
                                            </div>
                                }
                                else
                                {
                                            <div class="no-subtasks">No subtasks yet</div>
                                }

                                    <div class="add-subtask-form">
                                        <input type="text" class="form-input" @bind="newSubtaskDescription" placeholder="Add a subtask..." @onkeydown="HandleSubtaskKeyDown" />
                                        <button type="button" class="btn-primary" @onclick="AddSubtaskToCurrentTask">Add</button>
                                    </div>
                                </div>
                        }

                        <div class="modal-footer">
                            <button type="button" class="btn-secondary" @onclick="HideModal">Cancel</button>
                            <button type="submit" class="btn-primary">Save</button>
                        </div>
                    </EditForm>
                </div>
            </div>
        </div>
    }
    @if (showUserContextModal)
    {
                    <div class="modal-backdrop"></div>
        <div class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>User Context Settings</h3>
                    <button class="close-button" @onclick="HideModal">×</button>
                </div>
                <div class="modal-body">
                    <!-- Work Description -->
                    <div class="form-group context-group">
                        <div class="context-header">
                            <label for="workDescription">Work Description</label>
                            <div class="context-pill @GetContextLevelClass(userContext.WorkDescription)">
                                @GetContextLevelText(userContext.WorkDescription)
                            </div>
                        </div>
                        <textarea id="workDescription" class="form-textarea" 
                            @bind="userContext.WorkDescription" 
                            @bind:event="oninput"
                            @onchange="StateHasChanged"
                            rows="3" 
                            placeholder="Describe your work, role, or current project..."></textarea>
                    </div>

                    <!-- Short Term Focus -->
                    <div class="form-group context-group">
                        <div class="context-header">
                            <label for="shortTermFocus">Short Term Focus</label>
                            <div class="context-pill @GetContextLevelClass(shortTermFocus)">
                                @GetContextLevelText(shortTermFocus)
                            </div>
                        </div>
                        <textarea id="shortTermFocus" class="form-textarea" 
                            @bind="shortTermFocus" 
                            @bind:event="oninput"
                            @onchange="StateHasChanged"
                            rows="3" 
                            placeholder="What are you focusing on in the short term? E.g., completing project X, learning skill Y..."></textarea>
                    </div>

                    <!-- Long Term Goals -->
                    <div class="form-group context-group">
                        <div class="context-header">
                            <label for="longTermGoals">Long Term Goals</label>
                            <div class="context-pill @GetContextLevelClass(longTermGoals)">
                                @GetContextLevelText(longTermGoals)
                            </div>
                        </div>
                        <textarea id="longTermGoals" class="form-textarea" 
                            @bind="longTermGoals" 
                            @bind:event="oninput"
                            @onchange="StateHasChanged"
                            rows="3" 
                            placeholder="What are your long-term goals? E.g., career growth, skill mastery, project completion..."></textarea>
                    </div>

                    <!-- Sorting Preferences -->
                    <div class="form-group">
                        <label>Sorting Preferences</label>
                        <div class="radio-group">
                            <label class="radio-label">
                                <input type="radio" name="sortPreference" value="DueDate" 
                                    checked="@(userContext.SortPreference == TaskSortPreference.DueDate)" 
                                    @onchange="() => userContext.SortPreference = TaskSortPreference.DueDate" />
                                Due Date
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="sortPreference" value="Priority" 
                                    checked="@(userContext.SortPreference == TaskSortPreference.Priority)" 
                                    @onchange="() => userContext.SortPreference = TaskSortPreference.Priority" />
                                Priority
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="sortPreference" value="CreationDate" 
                                    checked="@(userContext.SortPreference == TaskSortPreference.CreationDate)" 
                                    @onchange="() => userContext.SortPreference = TaskSortPreference.CreationDate" />
                                Creation Date
                            </label>
                        </div>
                    </div>

                    <!-- AI Settings -->
                    <div class="form-group">
                        <div class="form-check">
                            <InputCheckbox id="useReasoning" @bind-Value="userContext.UseReasoning" />
                            <label for="useReasoning">Use AI reasoning capabilities</label>
                        </div>
                    </div>

                    <div class="modal-footer">
                        <button class="btn-secondary" @onclick="HideModal">Cancel</button>
                        <button class="btn-primary" @onclick="SaveUserContext">Save</button>
                    </div>
                </div>
            </div>
        </div>
    }
    @if (showSubtaskModal)
    {
                    <div class="modal-backdrop"></div>
        <div class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Add Subtask</h3>
                        <button class="close-button" @onclick="HideModal">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="subtaskDescription">Description</label>
                            <input id="subtaskDescription" class="form-input" @bind="newSubtaskDescription" />
                        </div>

                        <div class="modal-footer">
                            <button class="btn-secondary" @onclick="HideModal">Cancel</button>
                            <button class="btn-primary" @onclick="AddSubtaskAsync">Add</button>
                        </div>
                    </div>
                </div>
            </div>
    }
    @if (showSettingsModal)
    {
        <div class="modal-backdrop"></div>
        <div class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Settings</h3>
                    <button class="close-button" @onclick="() => showSettingsModal = false">×</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="workDescription">Work Description</label>
                        <textarea id="workDescription" class="form-textarea" @bind="userSettings.WorkDescription" rows="3"></textarea>
                    </div>

                    <div class="form-group">
                        <label>Focus Areas</label>
                        <div class="flex flex-wrap gap-2 mt-2">
                            @foreach (var area in userSettings.FocusAreas)
                            {
                                    <div class="bg-gray-200 px-2 py-1 rounded text-sm flex items-center">
                                        <span>@area</span>
                                        <button class="ml-2 text-gray-500" @onclick="() => RemoveFocusArea(area)">×</button>
                                    </div>
                            }
                            <div class="flex">
                                <input type="text" class="form-input" @bind="newFocusArea" placeholder="Add focus area..." />
                                <button class="btn-primary ml-2" @onclick="AddFocusArea">Add</button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Preferred AI Model</label>
                        <select class="form-select" @bind="userSettings.PreferredModel">
                            <option value="qwen32b">Qwen 32B</option>
                        </select>
                    </div>

                    <div class="modal-footer">
                        <button class="btn-secondary" @onclick="() => showSettingsModal = false">Cancel</button>
                        <button class="btn-primary" @onclick="SaveSettings">Save</button>
                    </div>
                </div>
            </div>
        </div>
    }

    @if (showCompletedTasksModal)
    {
                <div class="modal-backdrop"></div>
        <div class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Completed Tasks</h3>
                    <button class="close-button" @onclick="() => showCompletedTasksModal = false">×</button>
                </div>
                <div class="modal-body">
                    @if (!completedTasks.Any())
                    {
                            <div class="empty-state py-8">
                                <p>No completed tasks yet.</p>
                            </div>
                    }
                    else
                    {
                            <div class="completed-tasks-list max-h-96 overflow-y-auto">
                            @foreach (var task in completedTasks)
                            {
                                        <div class="task-item completed">
                                            <div class="task-main">
                                                <div class="task-checkbox">
                                                    <input type="checkbox" checked disabled />
                                                </div>
                                                <div class="task-content">
                                                    <div class="task-title">@task.Title</div>
                                            @if (!string.IsNullOrEmpty(task.Description))
                                            {
                                                            <div class="task-description">@task.Description</div>
                                            }
                                                    <div class="task-metadata">
                                                        <span>Completed: @task.CreatedDate.ToShortDateString()</span>
                                                    </div>
                                                </div>
                                                <div class="task-actions">
                                                    <button class="btn btn-sm btn-outline-primary" 
                                                            title="Reactivate task" 
                                                            @onclick="() => ReactivateTaskAsync(task)">
                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18m-18 0l5-5m-5 5l5 5"></path></svg>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                            }
                            </div>
                    }
                </div>
            </div>
        </div>
    }
    @if (showRelevantConversations)
    {
        <div class="modal-backdrop"></div>
        <div class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Related Past Conversations</h3>
                    <button class="close-button" @onclick="() => showRelevantConversations = false">×</button>
                </div>
                <div class="modal-body">
                    <p>I found previous conversations that might be relevant:</p>
                    <div class="conversation-list">
                        @foreach (var conv in relevantConversations)
                        {
                                <div class="conversation-item">
                                    <div class="conversation-title">@conv.Title</div>
                                    <div class="conversation-date">@conv.CreatedDate.ToShortDateString()</div>
                                    <div class="conversation-summary">@conv.Summary</div>
                                    <div class="conversation-tags">
                                    @foreach (var tag in conv.Tags)
                                    {
                                                <span class="tag">@tag</span>
                                    }
                                    </div>
                                    <button class="btn-primary" @onclick="() => ReferencePastConversation(conv)">
                                        Reference This
                                    </button>
                                </div>
                        }
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-secondary" @onclick="() => showRelevantConversations = false">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    }


</div>

@code {
    // Task-related properties
    private List<TaskItem> tasks;
    private List<TaskItem> overdueTasks = new List<TaskItem>();
    private List<TaskItem> regularTasks = new List<TaskItem>();
    private TaskItem newTask = new TaskItem();
    private TaskItem currentTask;
    private string newSubtaskDescription;
    private bool loading = true;
    private bool showNewTaskModal = false;
    private bool showSubtaskModal = false;
    private bool editingTask = false;
    private string currentSortOption = "DueDate";

    // Chat-related properties
    private List<ChatMessage> messages = new List<ChatMessage>();
    private List<MessageHistory> conversationHistory = new List<MessageHistory>();
    private string currentMessage = "";
    private bool isStreaming = false;
    private string currentStreamedContent = "";
    private string currentReasoningContent = "";
    private string selectedModel = "qwen32b";
    private bool useReasoning = true;
    private bool showReasoning = true;
    private ElementReference chatMessagesElement;
    private ElementReference textAreaRef;
    private CancellationTokenSource cts = new CancellationTokenSource(); // Initialize here to avoid null reference


    private bool showSettingsModal = false;
    private bool showCompletedTasksModal = false;
    private List<TaskItem> completedTasks = new List<TaskItem>();
    private UserSettings userSettings = new UserSettings();

    private string shortTermFocus = ""; // Will store concatenated focus areas
    private string longTermGoals = ""; // Will store concatenated long-term goals

    // For task detection
    private Dictionary<int, TaskDetectionResult> taskSuggestions = new Dictionary<int, TaskDetectionResult>();
    private TaskItem taskFromMessage = new TaskItem();

    private TaskItem taskFromSuggestion = new TaskItem();
    private bool showTaskFromSuggestionModal = false;
    private bool showTaskCreationModal = false;
    private int currentTaskMessageIndex = -1;

     private bool autoScroll = true;
    private bool showScrollButton = false;

    // User context setup with proper defaults
    private UserContext userContext = new UserContext
        {
            WorkDescription = "Developing a productivity application",
            FocusAreas = new List<string> { "Task Management", "Note Taking", "AI Integration" },
            LongTermGoals = new List<string> { "Build a seamless productivity system", "Reduce context switching", "Leverage AI for better efficiency" },
            PreferredAIModel = "qwen32b", // Match the default model selection
            UseReasoning = true // Ensure this matches the UI setting
        };

    // Combined lifecycle methods
    protected override async Task OnInitializedAsync()
    {
        // Load existing conversation if any
        var savedHistory = await ConversationService.LoadActiveConversationAsync();

        if (savedHistory != null && savedHistory.Any())
        {
            // Debug output to help diagnose issues
            Console.WriteLine($"Loaded {savedHistory.Count} messages from storage");
            foreach (var msg in savedHistory)
            {
                Console.WriteLine($"Message: {(msg.IsUserMessage ? "User" : "AI")}: {msg.Content.Substring(0, Math.Min(20, msg.Content.Length))}...");
            }

            conversationHistory = savedHistory;

            // Rebuild UI messages from history
            messages = conversationHistory.Select(m => new ChatMessage
                {
                    Content = m.Content,
                    IsFromUser = m.IsUserMessage,
                    ReasoningContent = m.ReasoningContent,
                    HasReasoning = !string.IsNullOrEmpty(m.ReasoningContent)
                }).ToList();

            Console.WriteLine($"Rebuilt {messages.Count} UI messages");
        }
        else
        {
            Console.WriteLine("No saved conversation found or loading failed");
            // Add welcome message if no history
            AddWelcomeMessage();
        }

        await LoadTasksAsync();
    }
    private void AddWelcomeMessage()
    {
        var welcomeMessage = "Hello! I'm your ProductivAI assistant. How can I help you today?";

        messages.Add(new ChatMessage
            {
                Content = welcomeMessage,
                IsFromUser = false
            });

        conversationHistory.Add(new MessageHistory
            {
                Content = welcomeMessage,
                IsUserMessage = false,
                Timestamp = DateTime.Now
            });
    }

    // Track expanded state for reasoning sections
    private bool expandedReasoning = false;
    private Dictionary<ChatMessage, bool> reasoningExpandedStates = new Dictionary<ChatMessage, bool>();

    private void ToggleReasoningExpansion()
    {
        expandedReasoning = !expandedReasoning;
    }

    private void ToggleMessageReasoningExpansion(ChatMessage message)
    {
        if (!reasoningExpandedStates.ContainsKey(message))
        {
            reasoningExpandedStates[message] = true;
        }
        else
        {
            reasoningExpandedStates[message] = !reasoningExpandedStates[message];
        }
    }
    private void RemoveSubtask(SubTask subtask)
    {
        newTask.SubTasks.Remove(subtask);
    }

    private void AddSubtaskToCurrentTask()
    {
        if (string.IsNullOrWhiteSpace(newSubtaskDescription))
            return;

        newTask.SubTasks.Add(new SubTask
            {
                Description = newSubtaskDescription,
                IsCompleted = false
            });

        newSubtaskDescription = ""; // Clear the input
    }

    private void HandleSubtaskKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(newSubtaskDescription))
        {
            AddSubtaskToCurrentTask();
        }
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Store a reference to this component in JavaScript
            await JSRuntime.InvokeVoidAsync("eval", @"
            document.addEventListener('click', function(e) {
                if (e.target && e.target.classList.contains('task-action-button')) {
                    DotNet.invokeMethodAsync('ProductivAI', 'ShowTaskModal');
                }
            });
        ");

            // Setup scroll handler 
            await JSRuntime.InvokeVoidAsync("setupChatScroll",
                chatMessagesElement,
                DotNetObjectReference.Create(this));

            // Any other first render initialization...
        }

        // Other existing code...
        await ScrollToBottomAsync();
    }


    private async Task DisableShortcutsAsync()
    {
        await JSRuntime.InvokeVoidAsync("shortcutsManager.setTypingState", true);
    }

    private async Task EnableShortcutsAsync()
    {
        await JSRuntime.InvokeVoidAsync("shortcutsManager.setTypingState", false);
    }
    public void Dispose()
    {
        cts?.Cancel();
        cts?.Dispose();
    }

    private string newFocusArea = "";

    // User settings class
    private class UserSettings
    {
        public string WorkDescription { get; set; } = "";
        public List<string> FocusAreas { get; set; } = new List<string>();
        public string PreferredModel { get; set; } = "qwen32b";
    }

    // Methods for settings
    private void AddFocusArea()
    {
        if (!string.IsNullOrWhiteSpace(newFocusArea) && !userSettings.FocusAreas.Contains(newFocusArea))
        {
            userSettings.FocusAreas.Add(newFocusArea);
            userContext.FocusAreas.Add(newFocusArea);
            newFocusArea = "";
        }
    }
    private void RemoveFocusArea(string area)
    {
        userSettings.FocusAreas.Remove(area);
        userContext.FocusAreas.Remove(area);
    }

    // ----- TASK MANAGEMENT METHODS -----
    private static Home CurrentInstance;
    protected override void OnInitialized()
    {
        base.OnInitialized();
        CurrentInstance = this;
    }
    [JSInvokable]
    public static Task ShowTaskModal()
    {
        // We need a static field to hold a reference to the component instance
        if (CurrentInstance != null)
        {
            CurrentInstance.ShowTaskModal();
        }
        return Task.CompletedTask;
    }
    private async Task LoadTasksAsync()
    {
        loading = true;
        StateHasChanged();

        try
        {
            // Get active tasks
            var activeTasks = await TaskService.GetActiveTasksAsync();
            tasks = activeTasks.ToList();

            // Split into overdue and regular tasks
            DateTime today = DateTime.Today;
            overdueTasks = tasks
                .Where(t => t.DueDate.HasValue && t.DueDate.Value < today)
                .ToList();

            regularTasks = tasks
                .Where(t => !t.DueDate.HasValue || t.DueDate.Value >= today)
                .ToList();

            // Apply current sort
            await SortTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error loading tasks: {ex.Message}");
        }
        finally
        {
            loading = false;
            StateHasChanged();
        }
    }

    private async Task SortTasksAsync()
    {
        // Using ProductivAI.Core.Models.TaskSortPreference directly
        var sortPreference = ProductivAI.Core.Models.TaskSortPreference.DueDate;
        Enum.TryParse(currentSortOption, out sortPreference);

        // Sort overdue tasks
        overdueTasks = sortPreference switch
        {
            ProductivAI.Core.Models.TaskSortPreference.DueDate => overdueTasks
                .OrderBy(t => t.DueDate.HasValue ? t.DueDate.Value : DateTime.MaxValue)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.Priority => overdueTasks
                .OrderByDescending(t => t.Priority)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.CreationDate => overdueTasks
                .OrderBy(t => t.CreatedDate)
                .ToList(),
            _ => overdueTasks
        };

        // Sort regular tasks
        regularTasks = sortPreference switch
        {
            ProductivAI.Core.Models.TaskSortPreference.DueDate => regularTasks
                .OrderBy(t => t.DueDate.HasValue ? t.DueDate.Value : DateTime.MaxValue)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.Priority => regularTasks
                .OrderByDescending(t => t.Priority)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.CreationDate => regularTasks
                .OrderBy(t => t.CreatedDate)
                .ToList(),
            _ => regularTasks
        };

        StateHasChanged();
    }

    private async Task ShowNewTaskModal()
    {
        newTask = new TaskItem
            {
                Priority = 3 // Default priority
            };
        editingTask = false;
        showNewTaskModal = true;
        // Comment out these lines temporarily
        await JSRuntime.InvokeVoidAsync("shortcutsManager.setModalState", true);
        StateHasChanged();
    }

    private void EditTask(TaskItem task)
    {
        newTask = new TaskItem
            {
                Id = task.Id,
                Title = task.Title,
                Description = task.Description,
                DueDate = task.DueDate,
                Priority = task.Priority,
                IsRecurring = task.IsRecurring,
                RecurrencePattern = task.RecurrencePattern,
                CreatedDate = task.CreatedDate,
                SubTasks = task.SubTasks
            };
        editingTask = true;
        showNewTaskModal = true;
    }

    private void ShowAddSubtaskModal(TaskItem task)
    {
        currentTask = task;
        newSubtaskDescription = string.Empty;
        showSubtaskModal = true;
    }


    private async Task HideModal()
    {
        showNewTaskModal = false;
        showSubtaskModal = false;
        showSettingsModal = false;
        showUserContextModal = false;
        showCompletedTasksModal = false;
        await JSRuntime.InvokeVoidAsync("shortcutsManager.setModalState", false);
        //await EnableShortcutsAsync();
    }

    private async Task SaveTaskAsync()
    {
        try
        {
            if (editingTask)
            {
                await TaskService.UpdateTaskAsync(newTask);
            }
            else
            {
                await TaskService.CreateTaskAsync(
                    newTask.Title,
                    newTask.Description,
                    newTask.DueDate,
                    newTask.Priority
                );
            }

            HideModal();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error saving task: {ex.Message}");
        }
    }

    private async Task AddSubtaskAsync()
    {
        if (string.IsNullOrWhiteSpace(newSubtaskDescription))
            return;

        try
        {
            await TaskService.AddSubTaskAsync(currentTask.Id, newSubtaskDescription);
            HideModal();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error adding subtask: {ex.Message}");
        }
    }

    private async Task CompleteTaskAsync(TaskItem task)
    {
        try
        {
            await TaskService.CompleteTaskAsync(task.Id);
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error completing task: {ex.Message}");
        }
    }

    // ----- CHAT METHODS -----
    private void PrepareTaskSuggestion(TaskSuggestion suggestion)
    {
        taskFromSuggestion = new TaskItem
            {
                Title = suggestion.Title ?? "New Task",
                Description = suggestion.Description ?? "",
                Priority = suggestion.Priority,
                DueDate = suggestion.DueDate
            };

        taskFromSuggestion.SubTasks.Clear();
        if (suggestion.Subtasks != null)
        {
            foreach (var subtask in suggestion.Subtasks)
            {
                taskFromSuggestion.SubTasks.Add(new SubTask
                    {
                        Description = subtask,
                        IsCompleted = false
                    });
            }
        }
    }
    [JSInvokable]
    public void ShowTaskSuggestionModal()
    {
        newTask = taskFromSuggestion;
        editingTask = false;
        showNewTaskModal = true;
        StateHasChanged();
    }
    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isStreaming)
            return;

        // Add user message
        var userInput = currentMessage.Trim();
        var userMessage = new ChatMessage
            {
                Content = userInput,
                IsFromUser = true
            };

        messages.Add(userMessage);
        // After adding user message to messages list


        // Add to conversation history
        conversationHistory.Add(new MessageHistory
            {
                Content = userInput,
                IsUserMessage = true,
                Timestamp = DateTime.Now // Add timestamp
            });

        // Save after adding user message
        await ConversationService.SaveActiveConversationAsync(conversationHistory);

        // Clear input and update UI
        currentMessage = "";
        StateHasChanged();
        await ScrollToBottomAsync();
        await ResizeTextAreaAsync();

        // Start streaming response
        isStreaming = true;
        currentStreamedContent = "";
        currentReasoningContent = "";
        StateHasChanged();

        // Set up cancellation token
        cts?.Cancel();
        cts = new CancellationTokenSource();

        // Update user context preferences
        userContext.PreferredAIModel = selectedModel;
        userContext.UseReasoning = useReasoning;

        try
        {
            // Process with AI and stream the response
            await AIService.ProcessQueryWithStreamingWithHistoryAsync(
                userInput,
                userContext,
                conversationHistory,
                async (token, isComplete) =>
                {
                    if (!isComplete)
                    {
                        // Check if this is a reasoning token
                        if (token.Contains("[REASONING]") && token.Contains("[/REASONING]"))
                        {
                            // Extract the reasoning content
                            int startIndex = token.IndexOf("[REASONING]");
                            int endIndex = token.IndexOf("[/REASONING]");
                            string reasoningContent = token.Substring(
                            startIndex + "[REASONING]".Length,
                            endIndex - startIndex - "[REASONING]".Length);

                            // Add to reasoning content
                            currentReasoningContent += reasoningContent;
                        }
                        else
                        {
                            // Regular content token
                            currentStreamedContent += token;
                        }

                        await InvokeAsync(StateHasChanged);
                        await InvokeAsync(ScrollToBottomAsync);
                    }
                    else
                    {
                        isStreaming = false;

                        if (!string.IsNullOrEmpty(currentStreamedContent))
                        {
                            // Create message with both content and reasoning
                            var aiMessage = new ChatMessage
                                {
                                    Content = currentStreamedContent,
                                    IsFromUser = false,
                                    ReasoningContent = currentReasoningContent,
                                    HasReasoning = !string.IsNullOrEmpty(currentReasoningContent)
                                };

                            messages.Add(aiMessage);
                            reasoningExpandedStates[aiMessage] = false; // Initially collapsed

                            // Add to conversation history with timestamp
                            var historyMessage = new MessageHistory
                                {
                                    Content = currentStreamedContent,
                                    IsUserMessage = false,
                                    ReasoningContent = currentReasoningContent,
                                    Timestamp = DateTime.Now
                                };

                            conversationHistory.Add(historyMessage);

                            // CRITICAL ADDITION: Save conversation after AI response
                            await ConversationService.SaveActiveConversationAsync(conversationHistory);

                            currentStreamedContent = "";
                            currentReasoningContent = "";
                        }

                        await InvokeAsync(StateHasChanged);
                        await InvokeAsync(ScrollToBottomAsync);
                    }
                },
                cts.Token
            );
        }
        catch (Exception ex)
        {
            // Handle error
            isStreaming = false;
            var errorMessage = new ChatMessage
                {
                    Content = $"An error occurred: {ex.Message}",
                    IsFromUser = false
                };

            messages.Add(errorMessage);

            // Add error to conversation history
            conversationHistory.Add(new MessageHistory
                {
                    Content = errorMessage.Content,
                    IsUserMessage = false,
                    Timestamp = DateTime.Now
                });

            // Save conversation even when errors occur
            await ConversationService.SaveActiveConversationAsync(conversationHistory);

            StateHasChanged();
            await ScrollToBottomAsync();
        }
    }
    private void ShowTaskCreationModal(int messageIndex)
    {
        var suggestion = taskSuggestions[messageIndex];
        currentTaskMessageIndex = messageIndex;

        // Create pre-filled task
        taskFromMessage = new TaskItem
            {
                Title = suggestion.SuggestedTitle,
                Description = suggestion.SuggestedDescription,
                Priority = suggestion.SuggestedPriority,
                DueDate = suggestion.SuggestedDueDate
            };

        // Add suggested subtasks
        taskFromMessage.SubTasks.Clear();
        foreach (var subtask in suggestion.SuggestedSubTasks ?? new List<string>())
        {
            taskFromMessage.SubTasks.Add(new SubTask
                {
                    Description = subtask,
                    IsCompleted = false
                });
        }

        showTaskCreationModal = true;
        StateHasChanged();
    }

    private void AddSubtaskToTaskFromMessage()
    {
        if (string.IsNullOrWhiteSpace(newSubtaskDescription))
            return;

        taskFromMessage.SubTasks.Add(new SubTask
            {
                Description = newSubtaskDescription,
                IsCompleted = false
            });

        newSubtaskDescription = "";
    }

    private async Task CreateTaskFromMessage()
    {
        try
        {
            // Create the main task
            var createdTask = await TaskService.CreateTaskAsync(
                taskFromMessage.Title,
                taskFromMessage.Description,
                taskFromMessage.DueDate,
                taskFromMessage.Priority
            );

            // Add subtasks
            if (taskFromMessage.SubTasks.Any())
            {
                foreach (var subtask in taskFromMessage.SubTasks)
                {
                    await TaskService.AddSubTaskAsync(createdTask.Id, subtask.Description);
                }
            }

            // Remove the suggestion to prevent duplicate creation
            taskSuggestions.Remove(currentTaskMessageIndex);

            // Add confirmation message to chat
            var confirmation = $"✅ Created task: \"{taskFromMessage.Title}\"";
            if (taskFromMessage.DueDate.HasValue)
            {
                confirmation += $" due {taskFromMessage.DueDate.Value.ToShortDateString()}";
            }

            // Add to conversation
            conversationHistory.Add(new MessageHistory
                {
                    Content = confirmation,
                    IsUserMessage = false,
                    Timestamp = DateTime.Now
                });

            messages.Add(new ChatMessage
                {
                    Content = confirmation,
                    IsFromUser = false
                });

            await ConversationService.SaveActiveConversationAsync(conversationHistory);

            // Close modal
            showTaskCreationModal = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Handle errors
            Console.Error.WriteLine($"Error creating task: {ex.Message}");
        }
    }
    private void SendSuggestedPrompt(string prompt)
    {
        currentMessage = prompt;
        StateHasChanged();
        SendMessageAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey && !string.IsNullOrWhiteSpace(currentMessage) && !isStreaming)
        {

            await SendMessageAsync();
        }
    }

    private void ClearChat()
    {
        messages.Clear();
        conversationHistory.Clear();
        StateHasChanged();
    }



    private async Task ScrollToBottomAsync()
    {
        if (autoScroll)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("scrollToEnd", chatMessagesElement);
            }
            catch
            {
                // Ignore errors if the element isn't rendered yet
            }
        }
    }

    private async Task ForceScrollToBottom()
    {
        autoScroll = true;
        showScrollButton = false;
        await JSRuntime.InvokeVoidAsync("scrollToEnd", chatMessagesElement);
        StateHasChanged();
    }

    private async Task ResizeTextAreaAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("textAreaManager.adjustHeight", textAreaRef);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error resizing: {ex.Message}");
        }
    }

    private string FormatMessageContent(string content)
    {
        if (string.IsNullOrEmpty(content))
            return "";

        // Process task suggestions first
        content = ProcessMessageContent(content);

        // Configure Markdig with minimal settings
        var pipeline = new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .DisableHtml()
            .Build();

        // Convert markdown to HTML
        string html = Markdown.ToHtml(content, pipeline);

        // Clean up any problematic patterns
        html = System.Text.RegularExpressions.Regex.Replace(html, @"<p>\s*</p>", "");

        return html;
    }

    private async Task ReactivateTaskAsync(TaskItem task)
    {
        try
        {
            await TaskService.ReactivateTaskAsync(task.Id);
            await LoadCompletedTasksAsync();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error reactivating task: {ex.Message}");
        }
    }

    private TaskSuggestion lastTaskSuggestion;
    private string lastTaskSuggestionId = Guid.NewGuid().ToString();
    private string ProcessMessageContent(string content)
    {
        if (string.IsNullOrEmpty(content))
            return content;

        // Look for task suggestion blocks
        const string taskStartTag = "<task-suggestion>";
        const string taskEndTag = "</task-suggestion>";

        int taskStart = content.IndexOf(taskStartTag);
        if (taskStart >= 0)
        {
            int taskEnd = content.IndexOf(taskEndTag, taskStart);
            if (taskEnd > taskStart)
            {
                try
                {
                    // Extract the task JSON
                    int jsonStart = taskStart + taskStartTag.Length;
                    string taskJson = content.Substring(jsonStart, taskEnd - jsonStart).Trim();

                    // Parse the task data
                    var taskSuggestion = JsonSerializer.Deserialize<TaskSuggestion>(
                        taskJson,
                        new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
                    );

                    if (taskSuggestion != null)
                    {
                        // Store the task data for later use - important to save it to a global variable 
                        lastTaskSuggestion = taskSuggestion;

                        // Remove the task suggestion block from the message
                        string beforeTask = content.Substring(0, taskStart);
                        string afterTask = content.Substring(taskEnd + taskEndTag.Length);

                        // Instead of trying to use javascript, add a data attribute that we can use for event handling
                        string taskHtml = "<div class=\"task-suggestion-block\">" +
                            "<p>I've identified a potential task in our conversation:</p>" +
                            "<div class=\"task-suggestion-content\">" +
                            $"<h4>{taskSuggestion.Title}</h4>";

                        if (taskSuggestion.DueDate.HasValue)
                        {
                            taskHtml += $"<p>Due: {taskSuggestion.DueDate.Value.ToShortDateString()}</p>";
                        }

                        if (taskSuggestion.Priority > 0)
                        {
                            taskHtml += $"<p>Priority: {taskSuggestion.Priority}/5</p>";
                        }

                        // Add a "View and Create Task" button using a Blazor component
                        taskHtml += "</div>" +
                            "<div class=\"task-action-button\" data-task-id=\"" + lastTaskSuggestionId + "\">" +
                            "View and Create Task" +
                            "</div>" +
                            "</div>";

                        return beforeTask + taskHtml + afterTask;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error parsing task suggestion: {ex.Message}");

                    // Remove the invalid task block
                    string beforeTask = content.Substring(0, taskStart);
                    string afterTask = content.Substring(taskEnd + taskEndTag.Length);
                    return beforeTask + afterTask;
                }
            }
        }

        return content;
    }

    private async Task LoadCompletedTasksAsync()
    {
        try
        {
            var tasks = await TaskService.GetCompletedTasksAsync();
            completedTasks = tasks.ToList();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error loading completed tasks: {ex.Message}");
        }
    }
    private void SaveSettings()
    {
        // Update user context with settings
        userContext.WorkDescription = userSettings.WorkDescription;
        userContext.FocusAreas = new List<string>(userSettings.FocusAreas);
        selectedModel = userSettings.PreferredModel;
        userContext.PreferredAIModel = userSettings.PreferredModel;

        // Close modal
        showSettingsModal = false;
    }

    private bool showUserContextModal = false;
    private string newLongTermGoal = "";

    // Method to show the user context modal
    private void ShowUserContextModal()
    {
        // Convert list items to text for editing
        shortTermFocus = string.Join("\n", userContext.FocusAreas);
        longTermGoals = string.Join("\n", userContext.LongTermGoals);
        showUserContextModal = true;
    }

    private string GetContextLevelClass(string text)
    {
        int wordCount = CountWords(text);

        if (wordCount <= 10)
            return "context-low";
        else if (wordCount <= 30)
            return "context-medium";
        else
            return "context-high";
    }
    private string GetContextLevelText(string text)
    {
        int wordCount = CountWords(text);

        if (wordCount <= 10)
            return "Low Context";
        else if (wordCount <= 30)
            return "Medium Context";
        else
            return "High Context";
    }
    private int CountWords(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return 0;

        return text.Split(new char[] { ' ', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }

    // Methods for handling focus areas




    // Methods for handling long-term goals
    private void AddLongTermGoal()
    {
        if (!string.IsNullOrWhiteSpace(newLongTermGoal) && !userContext.LongTermGoals.Contains(newLongTermGoal))
        {
            userContext.LongTermGoals.Add(newLongTermGoal);
            newLongTermGoal = "";
        }
    }

    private void RemoveLongTermGoal(string goal)
    {
        userContext.LongTermGoals.Remove(goal);
    }

    // Method to handle keyboard input (Enter to add tags)
    private void HandleTagKeyDown(KeyboardEventArgs e, Action addAction)
    {
        if (e.Key == "Enter")
        {
            addAction();
        }
    }

    // Method to save user context
    private void SaveUserContext()
    {
        // Convert text areas back to lists
        userContext.FocusAreas = shortTermFocus
            .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => s.Trim())
            .Where(s => !string.IsNullOrWhiteSpace(s))
            .ToList();

        userContext.LongTermGoals = longTermGoals
            .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => s.Trim())
            .Where(s => !string.IsNullOrWhiteSpace(s))
            .ToList();

        // Update related variables
        useReasoning = userContext.UseReasoning;
        currentSortOption = userContext.SortPreference.ToString();

        // Apply sort preference immediately
        SortTasksAsync();

        // Close the modal
        showUserContextModal = false;
    }

    private async Task HandleChatScroll()
    {
        try
        {
            // Check if user has scrolled up
            var isAtBottom = await JSRuntime.InvokeAsync<bool>("isScrolledToBottom", chatMessagesElement);

            // If not at bottom, show the scroll button and disable auto-scroll
            if (!isAtBottom && !showScrollButton)
            {
                autoScroll = false;
                showScrollButton = true;
                StateHasChanged();
            }
            // If at bottom, hide the button and enable auto-scroll
            else if (isAtBottom && showScrollButton)
            {
                autoScroll = true;
                showScrollButton = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling scroll: {ex.Message}");
        }
    }
    // ----- KEYBOARD SHORTCUT HANDLERS -----

    [JSInvokable]
    public void HandleQuickCreateShortcut()
    {
        ShowNewTaskModal();
        StateHasChanged();
    }

    [JSInvokable]
    public async Task HandleSettingsShortcut()
    {
        // Initialize settings with current user context
        userSettings.WorkDescription = userContext.WorkDescription;
        userSettings.FocusAreas = new List<string>(userContext.FocusAreas);
        userSettings.PreferredModel = selectedModel;

        // Show settings modal
        showSettingsModal = true;
        await DisableShortcutsAsync();
        StateHasChanged();
    }

    [JSInvokable]
    public async Task HandleCompletedTasksShortcut()
    {
        // Load completed tasks
        await LoadCompletedTasksAsync();

        // Show completed tasks modal
        showCompletedTasksModal = true;
        await DisableShortcutsAsync();
        StateHasChanged();
    }

    private bool isEndingConversation = false;
    private List<ConversationSummary> relevantConversations = new List<ConversationSummary>();
    private bool showRelevantConversations = false;
    private async Task EndAndArchiveConversation()
    {
        if (isStreaming || conversationHistory.Count <= 1)
            return;

        isEndingConversation = true;
        StateHasChanged();

        try
        {
            // Use service to generate summary and archive
            var summary = await ConversationService.EndAndArchiveConversationAsync(
                conversationHistory,
                userContext
            );

            // Clear current conversation
            messages.Clear();
            conversationHistory.Clear();

            // Add welcome message
            messages.Add(new ChatMessage
                {
                    Content = $"Previous conversation archived as \"{summary.Title}\".\nHow can I help you today?",
                    IsFromUser = false
                });

            conversationHistory.Add(new MessageHistory
                {
                    Content = $"Previous conversation archived as \"{summary.Title}\".\nHow can I help you today?",
                    IsUserMessage = false
                });

            // Save the new state
            await ConversationService.SaveActiveConversationAsync(conversationHistory);
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error archiving conversation: {ex.Message}");
        }
        finally
        {
            isEndingConversation = false;
            StateHasChanged();
        }
    }

    // Add method to check for relevant past conversations
    private async Task CheckForRelevantConversations(string message)
    {
        // Don't check for very short messages
        if (string.IsNullOrWhiteSpace(message) || message.Length < 10)
            return;

        // Get current task ID if focusing on a task
        Guid? currentTaskId = null; // You would set this based on your UI state

        var relevant = await ConversationService.FindRelevantConversationsAsync(message, currentTaskId);

        if (relevant.Any())
        {
            relevantConversations = relevant;
            showRelevantConversations = true;
            StateHasChanged();
        }
    }

    // Add method to reference a past conversation
    private async Task ReferencePastConversation(ConversationSummary conversation)
    {
        // Add reference message to chat
        var referenceMessage = new MessageHistory
            {
                Content = $"From previous conversation about \"{conversation.Title}\" ({conversation.CreatedDate.ToShortDateString()}):\n\n{conversation.Summary}",
                IsUserMessage = false,
                Timestamp = DateTime.Now
            };

        conversationHistory.Insert(1, referenceMessage);

        messages.Insert(1, new ChatMessage
            {
                Content = referenceMessage.Content,
                IsFromUser = false
            });

        await ConversationService.SaveActiveConversationAsync(conversationHistory);
        showRelevantConversations = false;
        StateHasChanged();
    }

    // ----- CLASS DEFINITIONS -----

    private class ChatMessage
    {
        public string Content { get; set; }
        public bool IsFromUser { get; set; }
        public string ReasoningContent { get; set; }
        public bool HasReasoning { get; set; }
    }
}