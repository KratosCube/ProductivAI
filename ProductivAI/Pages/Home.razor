@layout EmptyLayout
@page "/"
@using ProductivAI.Application.Services
@using ProductivAI.Components
@using ProductivAI.Core.Models
@using ProductivAI.Core.Interfaces
@using ProductivAI.AIServices
@using Microsoft.JSInterop
@using System.Threading
@inject ITaskService TaskService
@inject ITaskRepository TaskRepository
@inject OpenRouterAIService AIService
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager


<div class="dashboard-container">
    <div class="dashboard-content">      
        <!-- Chat Panel - 60% width, no padding, aligned to top/left/bottom edges, no border -->
        <div class="chat-panel">            
            <div class="chat-messages" @ref="chatMessagesElement">
                @if (!messages.Any())
                {
                        <div class="empty-chat">
                            <div class="empty-chat-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                            </div>
                            <h3 class="text-xl font-medium mb-2">AI Assistant</h3>
                            <p class="text-gray-500 text-center max-w-md mb-6">
                                Ask me anything about your tasks and notes, or how I can help you be more productive.
                            </p>
                            <div class="suggested-prompts">
                                <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("What tasks should I prioritize today?")'>
                                    What tasks should I prioritize today?
                                </button>
                                <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("Help me organize my notes on project planning.")'>
                                    Help me organize my notes on project planning.
                                </button>
                                <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("Create a weekly review template for me.")'>
                                    Create a weekly review template for me.
                                </button>
                            </div>
                        </div>
                }
                else
                {
                    @foreach (var message in messages)
                    {
                                <div class="message @(message.IsFromUser ? "user-message" : "ai-message")">
                                    <div class="avatar @(message.IsFromUser ? "user-avatar" : "ai-avatar")">
                                @if (message.IsFromUser)
                                {
                                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                                }
                                else
                                {
                                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="9" x2="9" y2="21"></line><line x1="15" y1="9" x2="15" y2="21"></line></svg>
                                }
                                    </div>
                                    <div class="message-content">
                                        <div class="message-sender">
                                    @(message.IsFromUser ? "You" : "AI Assistant")
                                        </div>

                                @if (!message.IsFromUser && message.HasReasoning && showReasoning)
                                {
                                                <div class="reasoning-block">
                                                    <div class="reasoning-header">Reasoning:</div>
                                        @((MarkupString)FormatMessageContent(message.ReasoningContent))
                                                </div>
                                }

                                        <div class="message-text">
                                    @((MarkupString)FormatMessageContent(message.Content))
                                        </div>
                                    </div>
                                </div>
                    }

                    @if (isStreaming)
                    {
                                <div class="message ai-message">
                                    <div class="avatar ai-avatar">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="9" x2="9" y2="21"></line><line x1="15" y1="9" x2="15" y2="21"></line></svg>
                                    </div>
                                    <div class="message-content">
                                        <div class="message-sender">
                                            AI Assistant
                                        </div>

                                @if (useReasoning && showReasoning && !string.IsNullOrEmpty(currentReasoningContent))
                                {
                                                <div class="reasoning-block">
                                                    <div class="reasoning-header">Reasoning:</div>
                                        @((MarkupString)FormatMessageContent(currentReasoningContent))
                                                </div>
                                }

                                        <div class="message-text">
                                    @((MarkupString)FormatMessageContent(currentStreamedContent))
                                            <div class="typing-indicator">
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    }
                }
            </div>

            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <textarea 
    @bind="currentMessage" 
    @bind:event="oninput"
    @onkeydown="HandleKeyDown"
    placeholder="Ask your AI assistant..."
    class="chat-textarea"
    rows="1"
    disabled="@isStreaming"
    @ref="textAreaRef">
</textarea>
                    <button 
                        class="send-button"
                        @onclick="SendMessageAsync"
                        disabled="@(string.IsNullOrWhiteSpace(currentMessage) || isStreaming)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>

                <div class="chat-options">
                    <!-- Model selection moved here -->
                    <div class="model-select">
                        <select class="select-input" @bind="selectedModel" disabled="@isStreaming">
                            <option value="qwen32b">Qwen 32B</option>
                            <option value="Son35">Claude 3 Sonnet</option>
                            <option value="Son35-opus">Claude 3 Opus</option>
                            <option value="llama3">Llama 3</option>
                            <option value="mixtral">Mixtral 8x7B</option>
                        </select>
                    </div>

                    <!-- Changed to toggle switches -->
                    <div class="chat-option">
                        <label class="switch">
                            <input type="checkbox" @bind="useReasoning" disabled="@isStreaming" />
                            <span class="slider round"></span>
                        </label>
                        <span>Use reasoning</span>
                    </div>

                    <div class="chat-option">
                        <label class="switch">
                            <input type="checkbox" @bind="showReasoning" disabled="@(!useReasoning)" />
                            <span class="slider round"></span>
                        </label>
                        <span>Show reasoning</span>
                    </div>

                    <button class="btn-icon" @onclick="ClearChat" disabled="@isStreaming">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path></svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Tasks Panel with padding -->
        <div class="tasks-panel">
            <div class="panel-header">
                <h2 class="text-xl font-semibold">Tasks</h2>
                <div class="flex gap-2">
                    <button class="btn-primary" @onclick="ShowNewTaskModal">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                        New Task
                    </button>
                    <select class="select-input" @bind="currentSortOption" @bind:after="SortTasksAsync">
                        <option value="DueDate">Due Date</option>
                        <option value="Priority">Priority</option>
                        <option value="CreationDate">Creation Date</option>
                    </select>
                </div>
            </div>

            <div class="tasks-list">
                @if (loading)
                {
                        <div class="loading-spinner">
                            <div class="spinner"></div>
                            <span>Loading tasks...</span>
                        </div>
                }
                else if (tasks == null || !tasks.Any())
                {
                        <div class="empty-state">
                            <div class="empty-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                            </div>
                            <p>No tasks yet. Create your first task to get started.</p>
                        </div>
                }
                else
                {
                    @if (overdueTasks.Any())
                    {
                                <div class="task-group">
                                    <h4 class="text-red-600 font-medium">Overdue</h4>
                            @foreach (var task in overdueTasks)
                            {
                                            <TaskItemComponent Task="task" 
                                                            OnComplete="CompleteTaskAsync" 
                                                            OnEdit="EditTask" 
                                                            OnAddSubtask="ShowAddSubtaskModal" />
                            }
                                </div>
                    }

                        <div class="task-group">
                            <h4 class="font-medium">Tasks</h4>
                        @foreach (var task in regularTasks)
                        {
                                    <TaskItemComponent Task="task" 
                                                    OnComplete="CompleteTaskAsync" 
                                                    OnEdit="EditTask" 
                                                    OnAddSubtask="ShowAddSubtaskModal" />
                        }
                        </div>
                }
            </div>
        </div>
    </div>

    @if (showNewTaskModal)
    {
            <div class="modal-backdrop"></div>
            <div class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>@(editingTask ? "Edit Task" : "New Task")</h3>
                        <button class="close-button" @onclick="HideModal">×</button>
                    </div>
                    <div class="modal-body">
                        <EditForm Model="newTask" OnValidSubmit="SaveTaskAsync">
                            <DataAnnotationsValidator />
                            <ValidationSummary />

                            <div class="form-group">
                                <label for="title">Title</label>
                                <InputText id="title" class="form-input" @bind-Value="newTask.Title" />
                            </div>

                            <div class="form-group">
                                <label for="description">Description</label>
                                <InputTextArea id="description" class="form-textarea" @bind-Value="newTask.Description" rows="3" />
                            </div>

                            <div class="form-row">
                                <div class="form-group half">
                                    <label for="dueDate">Due Date</label>
                                    <InputDate id="dueDate" class="form-input" @bind-Value="newTask.DueDate" />
                                </div>
                                <div class="form-group half">
                                    <label for="priority">Priority (1-5)</label>
                                    <InputNumber id="priority" class="form-input" @bind-Value="newTask.Priority" min="1" max="5" />
                                </div>
                            </div>

                            <div class="form-check">
                                <InputCheckbox id="isRecurring" @bind-Value="newTask.IsRecurring" />
                                <label for="isRecurring">Recurring Task</label>
                            </div>

                        @if (newTask.IsRecurring)
                        {
                                    <div class="form-group">
                                        <label for="recurrencePattern">Recurrence Pattern</label>
                                        <InputSelect id="recurrencePattern" class="form-select" @bind-Value="newTask.RecurrencePattern">
                                            <option value="daily">Daily</option>
                                            <option value="weekly">Weekly</option>
                                            <option value="monthly">Monthly</option>
                                            <option value="yearly">Yearly</option>
                                            <option value="every 2 days">Every 2 Days</option>
                                            <option value="every 2 weeks">Every 2 Weeks</option>
                                        </InputSelect>
                                    </div>
                        }

                            <div class="modal-footer">
                                <button type="button" class="btn-secondary" @onclick="HideModal">Cancel</button>
                                <button type="submit" class="btn-primary">Save</button>
                            </div>
                        </EditForm>
                    </div>
                </div>
            </div>
    }

    @if (showSubtaskModal)
    {
            <div class="modal-backdrop"></div>
            <div class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Add Subtask</h3>
                        <button class="close-button" @onclick="HideModal">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="subtaskDescription">Description</label>
                            <input id="subtaskDescription" class="form-input" @bind="newSubtaskDescription" />
                        </div>

                        <div class="modal-footer">
                            <button class="btn-secondary" @onclick="HideModal">Cancel</button>
                            <button class="btn-primary" @onclick="AddSubtaskAsync">Add</button>
                        </div>
                    </div>
                </div>
            </div>
    }
</div>

@code {
    // Task-related properties
    private List<TaskItem> tasks;
    private List<TaskItem> overdueTasks = new List<TaskItem>();
    private List<TaskItem> regularTasks = new List<TaskItem>();
    private TaskItem newTask = new TaskItem();
    private TaskItem currentTask;
    private string newSubtaskDescription;
    private bool loading = true;
    private bool showNewTaskModal = false;
    private bool showSubtaskModal = false;
    private bool editingTask = false;
    private string currentSortOption = "DueDate";

    // Chat-related properties
    private List<ChatMessage> messages = new List<ChatMessage>();
    private List<MessageHistory> conversationHistory = new List<MessageHistory>();
    private string currentMessage = "";
    private bool isStreaming = false;
    private string currentStreamedContent = "";
    private string currentReasoningContent = "";
    private string selectedModel = "qwen32b";
    private bool useReasoning = true;
    private bool showReasoning = true;
    private ElementReference chatMessagesElement;
    private ElementReference textAreaRef;
    private CancellationTokenSource cts;
    private DotNetObjectReference<CallbackHandler> callbackReference;
    private UserContext userContext = new UserContext
        {
            WorkDescription = "Developing a productivity application",
            FocusAreas = new List<string> { "Task Management", "Note Taking", "AI Integration" },
            LongTermGoals = new List<string> { "Build a seamless productivity system", "Reduce context switching", "Leverage AI for better efficiency" }
        };

    // Combined lifecycle methods
    protected override async Task OnInitializedAsync()
    {
        await LoadTasksAsync();

        // Add a welcome message to chat
        messages.Add(new ChatMessage
            {
                Content = "Hello! I'm your ProductivAI assistant. How can I help you today?",
                IsFromUser = false
            });

        // Add to conversation history
        conversationHistory.Add(new MessageHistory
            {
                Content = "Hello! I'm your ProductivAI assistant. How can I help you today?",
                IsUserMessage = false
            });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("productivAIInterop.registerShortcuts",
                DotNetObjectReference.Create(this));
            await ScrollToBottomAsync();
            await ResizeTextAreaAsync();
        }
        else
        {
            await ScrollToBottomAsync();
        }
    }

    public void Dispose()
    {
        cts?.Cancel();
        cts?.Dispose();
        callbackReference?.Dispose();
    }

    // ----- TASK MANAGEMENT METHODS -----

    private async Task LoadTasksAsync()
    {
        loading = true;
        StateHasChanged();

        try
        {
            // Get active tasks
            var activeTasks = await TaskService.GetActiveTasksAsync();
            tasks = activeTasks.ToList();

            // Split into overdue and regular tasks
            DateTime today = DateTime.Today;
            overdueTasks = tasks
                .Where(t => t.DueDate.HasValue && t.DueDate.Value < today)
                .ToList();

            regularTasks = tasks
                .Where(t => !t.DueDate.HasValue || t.DueDate.Value >= today)
                .ToList();

            // Apply current sort
            await SortTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error loading tasks: {ex.Message}");
        }
        finally
        {
            loading = false;
            StateHasChanged();
        }
    }

    private async Task SortTasksAsync()
    {
        // Using ProductivAI.Core.Models.TaskSortPreference directly
        var sortPreference = ProductivAI.Core.Models.TaskSortPreference.DueDate;
        Enum.TryParse(currentSortOption, out sortPreference);

        // Sort overdue tasks
        overdueTasks = sortPreference switch
        {
            ProductivAI.Core.Models.TaskSortPreference.DueDate => overdueTasks
                .OrderBy(t => t.DueDate.HasValue ? t.DueDate.Value : DateTime.MaxValue)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.Priority => overdueTasks
                .OrderByDescending(t => t.Priority)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.CreationDate => overdueTasks
                .OrderBy(t => t.CreatedDate)
                .ToList(),
            _ => overdueTasks
        };

        // Sort regular tasks
        regularTasks = sortPreference switch
        {
            ProductivAI.Core.Models.TaskSortPreference.DueDate => regularTasks
                .OrderBy(t => t.DueDate.HasValue ? t.DueDate.Value : DateTime.MaxValue)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.Priority => regularTasks
                .OrderByDescending(t => t.Priority)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.CreationDate => regularTasks
                .OrderBy(t => t.CreatedDate)
                .ToList(),
            _ => regularTasks
        };

        StateHasChanged();
    }

    private void ShowNewTaskModal()
    {
        newTask = new TaskItem
            {
                Priority = 3 // Default priority
            };
        editingTask = false;
        showNewTaskModal = true;
    }

    private void EditTask(TaskItem task)
    {
        newTask = new TaskItem
            {
                Id = task.Id,
                Title = task.Title,
                Description = task.Description,
                DueDate = task.DueDate,
                Priority = task.Priority,
                IsRecurring = task.IsRecurring,
                RecurrencePattern = task.RecurrencePattern,
                CreatedDate = task.CreatedDate,
                SubTasks = task.SubTasks
            };
        editingTask = true;
        showNewTaskModal = true;
    }

    private void ShowAddSubtaskModal(TaskItem task)
    {
        currentTask = task;
        newSubtaskDescription = string.Empty;
        showSubtaskModal = true;
    }

    private void HideModal()
    {
        showNewTaskModal = false;
        showSubtaskModal = false;
    }

    private async Task SaveTaskAsync()
    {
        try
        {
            if (editingTask)
            {
                await TaskService.UpdateTaskAsync(newTask);
            }
            else
            {
                await TaskService.CreateTaskAsync(
                    newTask.Title,
                    newTask.Description,
                    newTask.DueDate,
                    newTask.Priority
                );
            }

            HideModal();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error saving task: {ex.Message}");
        }
    }

    private async Task AddSubtaskAsync()
    {
        if (string.IsNullOrWhiteSpace(newSubtaskDescription))
            return;

        try
        {
            await TaskService.AddSubTaskAsync(currentTask.Id, newSubtaskDescription);
            HideModal();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error adding subtask: {ex.Message}");
        }
    }

    private async Task CompleteTaskAsync(TaskItem task)
    {
        try
        {
            await TaskService.CompleteTaskAsync(task.Id);
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error completing task: {ex.Message}");
        }
    }

    // ----- CHAT METHODS -----

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isStreaming)
            return;

        // Add user message
        var userInput = currentMessage.Trim();
        var userMessage = new ChatMessage
            {
                Content = userInput,
                IsFromUser = true
            };

        messages.Add(userMessage);

        // Add to conversation history
        conversationHistory.Add(new MessageHistory
            {
                Content = userInput,
                IsUserMessage = true
            });

        // Clear input and update UI
        currentMessage = "";
        await InvokeAsync(StateHasChanged);
        await ScrollToBottomAsync();
        await ResizeTextAreaAsync();

        // Start streaming response
        isStreaming = true;
        currentStreamedContent = "";
        currentReasoningContent = "";
        await InvokeAsync(StateHasChanged);

        // Set up cancellation token
        cts?.Cancel();
        cts = new CancellationTokenSource();

        // Update user context preferences
        userContext.PreferredAIModel = selectedModel;
        userContext.UseReasoning = useReasoning;

        try
        {
            // Initialize reasoning parsing state
            bool inReasoningBlock = false;

            // Process with AI and stream the response
            await AIService.ProcessQueryWithStreamingWithHistoryAsync(
                userInput,
                userContext,
                conversationHistory,
                async (token, isComplete) =>
                {
                    if (!isComplete)
                    {
                        // Parse reasoning markers if present
                        if (token.Contains("[REASONING]"))
                        {
                            inReasoningBlock = true;
                            token = token.Replace("[REASONING]", "");
                        }
                        else if (token.Contains("[/REASONING]"))
                        {
                            inReasoningBlock = false;
                            token = token.Replace("[/REASONING]", "");
                        }

                        // Add to appropriate content stream
                        if (inReasoningBlock)
                        {
                            currentReasoningContent += token;
                        }
                        else
                        {
                            currentStreamedContent += token;
                        }

                        await InvokeAsync(StateHasChanged);
                        await InvokeAsync(ScrollToBottomAsync);
                    }
                    else
                    {
                        isStreaming = false;

                        if (!string.IsNullOrEmpty(currentStreamedContent))
                        {
                            // Create message with both content and reasoning
                            var aiMessage = new ChatMessage
                                {
                                    Content = currentStreamedContent,
                                    IsFromUser = false,
                                    ReasoningContent = currentReasoningContent,
                                    HasReasoning = !string.IsNullOrEmpty(currentReasoningContent)
                                };

                            messages.Add(aiMessage);

                            // Add to conversation history
                            conversationHistory.Add(new MessageHistory
                                {
                                    Content = currentStreamedContent,
                                    IsUserMessage = false,
                                    ReasoningContent = currentReasoningContent
                                });

                            currentStreamedContent = "";
                            currentReasoningContent = "";
                        }

                        await InvokeAsync(StateHasChanged);
                        await InvokeAsync(ScrollToBottomAsync);
                    }
                },
                cts.Token
            );
        }
        catch (Exception ex)
        {
            // Handle error
            isStreaming = false;
            messages.Add(new ChatMessage
                {
                    Content = $"An error occurred: {ex.Message}",
                    IsFromUser = false
                });

            await InvokeAsync(StateHasChanged);
            await InvokeAsync(ScrollToBottomAsync);
        }
    }


    private void SendSuggestedPrompt(string prompt)
    {
        currentMessage = prompt;
        StateHasChanged();
        SendMessageAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey && !string.IsNullOrWhiteSpace(currentMessage) && !isStreaming)
        {
            await SendMessageAsync();
        }
    }

    private void ClearChat()
    {
        messages.Clear();
        conversationHistory.Clear();
        StateHasChanged();
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            // Ensure this JavaScript function is defined in your project
            await JSRuntime.InvokeVoidAsync("scrollToEnd", chatMessagesElement);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error scrolling: {ex.Message}");
            // Continue execution even if scrolling fails
        }
    }

    private async Task ResizeTextAreaAsync()
    {
        try
        {
            // Ensure this JavaScript function is defined in your project
            await JSRuntime.InvokeVoidAsync("resizeTextArea", textAreaRef);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error resizing: {ex.Message}");
            // Continue execution even if resizing fails
        }
    }

    private string FormatMessageContent(string content)
    {
        if (string.IsNullOrEmpty(content))
            return "";

        // Simple markdown-like formatting
        // Code blocks
        content = System.Text.RegularExpressions.Regex.Replace(
            content,
            @"```(.+?)```",
            m => $"<pre><code>{m.Groups[1].Value}</code></pre>",
            System.Text.RegularExpressions.RegexOptions.Singleline
        );

        // Bold
        content = System.Text.RegularExpressions.Regex.Replace(
            content,
            @"\*\*(.+?)\*\*",
            "<strong>$1</strong>"
        );

        // Italic
        content = System.Text.RegularExpressions.Regex.Replace(
            content,
            @"\*(.+?)\*",
            "<em>$1</em>"
        );

        // Headers
        content = System.Text.RegularExpressions.Regex.Replace(
            content,
            @"^# (.+)$",
            "<h3>$1</h3>",
            System.Text.RegularExpressions.RegexOptions.Multiline
        );

        content = System.Text.RegularExpressions.Regex.Replace(
            content,
            @"^## (.+)$",
            "<h4>$1</h4>",
            System.Text.RegularExpressions.RegexOptions.Multiline
        );

        // Line breaks
        content = content.Replace("\n", "<br>");

        return content;
    }

    // ----- KEYBOARD SHORTCUT HANDLERS -----

    [JSInvokable]
    public void HandleQuickCreateShortcut()
    {
        ShowNewTaskModal();
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleSettingsShortcut()
    {
        NavigationManager.NavigateTo("/settings");
    }

    [JSInvokable]
    public void HandleCompletedTasksShortcut()
    {
        NavigationManager.NavigateTo("/completed");
    }

    // ----- CLASS DEFINITIONS -----

    private class ChatMessage
    {
        public string Content { get; set; }
        public bool IsFromUser { get; set; }
        public string ReasoningContent { get; set; }
        public bool HasReasoning { get; set; }
    }
}