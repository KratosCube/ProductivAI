@layout EmptyLayout
@page "/"
@using Markdig
@using ProductivAI.Application.Services
@using ProductivAI.Components
@using ProductivAI.Core.Models
@using ProductivAI.Core.Interfaces
@using ProductivAI.AIServices
@using Microsoft.JSInterop
@using System.Threading
@using System.Text.Json
@using System.Web
@using System.Text.RegularExpressions
@using System.Text
@inject ITaskService TaskService
@inject ITaskRepository TaskRepository
@inject OpenRouterAIService AIService
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject IConversationService ConversationService
@inject MessageFormattingService MessageFormatter

<div class="dashboard-container">
    <div class="dashboard-content">      
        <!-- Chat Panel - 60% width, no padding, aligned to top/left/bottom edges, no border -->
        <div class="chat-panel">            
            <div class="chat-messages bubble-chat" @ref="chatMessagesElement" @onscroll="HandleChatScroll">
                @if (!messages.Any())
                {
                            <div class="empty-chat">
                                <div class="empty-chat-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                                </div>
                                <h3 class="text-xl font-medium mb-2">AI Assistant</h3>
                                <p class="text-gray-500 text-center max-w-md mb-6">
                                    Ask me anything about your tasks and notes, or how I can help you be more productive.
                                </p>
                                <div class="suggested-prompts">
                                    <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("What tasks should I prioritize today?")'>
                                        What tasks should I prioritize today?
                                    </button>
                                    <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("Help me organize my notes on project planning.")'>
                                        Help me organize my notes on project planning.
                                    </button>
                                    <button class='btn btn-outline-primary' @onclick='() => SendSuggestedPrompt("Create a weekly review template for me.")'>
                                        Create a weekly review template for me.
                                    </button>
                                </div>
                            </div>
                }
                else
                {
                            <div class="messages-container">
                        @foreach (var message in messages)
                        {
                                            <div class="message-row @(message.IsFromUser ? "message-right" : "message-left")">
                                                <div class="avatar-container">
                                                    <div class="avatar @(message.IsFromUser ? "user-avatar" : "ai-avatar")">
                                        @if (message.IsFromUser)
                                        {
                                                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                                        }
                                        else
                                        {
                                                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="9" x2="9" y2="21"></line><line x1="15" y1="9" x2="15" y2="21"></line></svg>
                                        }
                                                    </div>
                                                </div>
                                                <div class="message-bubble">
                                                    <div class="message-content">
                                        @((MarkupString)message.FormattedContent)
                                                    </div>

                                    @if (!message.IsFromUser && message == messages.Last() && !isStreaming && extractedTasks.Any())
                                    {
                                        @foreach (var task in extractedTasks)
                                        {
                                                                            <TaskSuggestionComponent 
                                                                                Title="@task.Title"
                                                                                Description="@task.Description"
                                                                                Priority="@task.Priority"
                                                                                DueDate="@task.DueDate"
                                                                                Subtasks="@task.Subtasks" 
                                                                                OnShowModal="@((TaskSuggestion t) => ShowTaskModalWithData(t))" />
                                        }
                                    }
                                    @if (extractedTaskEdits.Any())
                                    {
                                        @foreach (var taskEdit in extractedTaskEdits)
                                        {
                                            @if (taskEdit.Original != null)
                                            {
                                        <TaskEditSuggestionComponent
                                            OriginalTask="@taskEdit.Original"
                                            EditedTask="@taskEdit.Edited"
                                            OnShowModal="@((data) => ShowTaskComparisonModal(data))" />
                                            }
                                        }
                                    }
                                                </div>
                                            </div>
                        }

                        @if (isStreaming)
                        {
                                            <div class="message-row message-left">
                                                <div class="avatar-container">
                                                    <div class="avatar ai-avatar">
                                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="9" x2="9" y2="21"></line><line x1="15" y1="9" x2="15" y2="21"></line></svg>
                                                    </div>
                                                </div>
                                                <div class="message-bubble">
                                    @if (useReasoning && !string.IsNullOrEmpty(currentReasoningContent))
                                    {
                                                                <div class="reasoning-container @(expandedReasoning ? "expanded" : "collapsed")" style="width: 100%; flex-shrink: 0;">
                                                                    <div class="reasoning-header" @onclick="ToggleReasoningExpansion">
                                                                        <div class="reasoning-title">
                                                                            <span>Reasoning</span>
                                                    @if (!expandedReasoning)
                                                    {
                                                                                        <div class="typing-indicator">
                                                                                            <span></span>
                                                                                            <span></span>
                                                                                            <span></span>
                                                                                        </div>
                                                    }
                                                                        </div>
                                                                        <button class="expand-button">
                                                    @if (expandedReasoning)
                                                    {
                                                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
                                                    }
                                                    else
                                                    {
                                                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                                                    }
                                                                        </button>
                                                                    </div>
                                            @foreach (var message in messages)
                                            {
                                                @if (expandedReasoning)
                                                {
                            <div class="reasoning-content">
                                                        @((MarkupString) FormatMessageContent(message.Content))
                            </div>
                                                }
                                            }
                                                                </div>
                                    }
                                                    <div class="message-content">
                                        @((MarkupString)FormatMessageContentWithoutTaskExtraction(currentStreamedContent))
                                                        <div class="typing-indicator">
                                                            <span></span>
                                                            <span></span>
                                                            <span></span>
                                                        </div>
                                                    </div>
                                                    <!-- No task suggestions shown during streaming -->
                                                </div>
                                            </div>
                        }
                            </div>
                }

                <!-- Add the floating scroll-to-bottom button -->
                <div class="scroll-bottom-button @(showScrollButton ? "visible" : "")" @onclick="ForceScrollToBottom">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
            </div>
            @if (showTaskSuggestions)
            {
            <div class="task-suggestions-dropdown" style="position: absolute; top: @(suggestionTop)px; left: @(suggestionLeft)px; z-index: 1000;">
                    @foreach (var task in suggestedTasks)
                    {
                            <div class="task-suggestion-item" @onclick="() => SelectTask(task)" @onclick:preventDefault @onclick:stopPropagation>
                                <div class="task-title">@task.Title</div>
                                <div class="task-details">
                                @if (task.DueDate.HasValue)
                                {
                                                <span class="task-due-date">Due: @task.DueDate.Value.ToShortDateString()</span>
                                }
                                    <span class="task-priority">P@(task.Priority)</span>
                                </div>
                            </div>
                    }
            </div>
            }
            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <textarea 
                        @bind="currentMessage" 
                        @bind:event="oninput"
                        @onkeydown="HandleKeyDown"
                        @onfocus="async () => await DisableShortcutsAsync()"
                        @onblur="async () => await EnableShortcutsAsync()"
                        placeholder="Ask your AI assistant..."
                        class="chat-textarea"
                        rows="1"
                        disabled="@isStreaming"
                        @ref="textAreaRef">
                    </textarea>
                    <button 
                        class="send-button"
                        @onclick="SendMessageAsync"
                        disabled="@(string.IsNullOrWhiteSpace(currentMessage) || isStreaming)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>

                <div class="chat-options">
                    <!-- Model selection moved here -->
                    <div class="model-select">
                        <select class="select-input" @bind="selectedModel" disabled="@isStreaming">
                            <option value="qwen32b">Qwen 32B</option>
                        </select>
                    </div>

                    <!-- Changed to toggle switches -->
                    <div class="chat-option">
                        <label class="switch">
                            <input type="checkbox" @bind="useReasoning" disabled="@isStreaming" />
                            <span class="slider round"></span>
                        </label>
                        <span>Use reasoning</span>
                    </div>

                    <div class="chat-option">
                        <label class="switch">
                            <input type="checkbox" @bind="showReasoning" disabled="@(!useReasoning)" />
                            <span class="slider round"></span>
                        </label>
                        <span>Show reasoning</span>
                    </div>

                    <button class="btn-icon" @onclick="ClearChat" disabled="@isStreaming">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path></svg>
                    </button>
                    <button class="btn-icon" @onclick="EndAndArchiveConversation" disabled="@(isStreaming || isEndingConversation)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                        End & Archive
                    </button>
                </div>
            </div>
        </div>

        <!-- Tasks Panel with padding -->
        <div class="tasks-panel">
            <div class="tasks-inner-container">
                <!-- Panel header -->
                <div class="panel-header">
                    <h2>Tasks</h2>
                    <div class="flex gap-2">
                        <button class="btn-new-task" @onclick="ShowEmptyNewTaskModal" title="New Task">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                        </button>
                        <button class="btn-new-task" @onclick="ShowUserContextModal" title="Edit User Context">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                        </button>
                        <select class="select-input" @bind="currentSortOption" @bind:after="SortTasksAsync">
                            <option value="DueDate">Due Date</option>
                            <option value="Priority">Priority</option>
                            <option value="CreationDate">Creation Date</option>
                        </select>
                    </div>
                </div>

                <div class="tasks-list">
                    @if (loading)
                    {
                                <div class="loading-spinner">
                                    <div class="spinner"></div>
                                    <span>Loading tasks...</span>
                                </div>
                    }
                    else if (tasks == null || !tasks.Any())
                    {
                                <div class="empty-state">
                                    <div class="empty-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                                    </div>
                                    <p>No tasks yet. Create your first task to get started.</p>
                                </div>
                    }
                    else
                    {
                        @if (overdueTasks.Any())
                        {
                                            <div class="task-group">
                                                <h4 class="text-red-600 font-medium">Overdue</h4>
                                @foreach (var task in overdueTasks)
                                {
                                                            <TaskItemComponent Task="task" 
                                                                OnComplete="CompleteTaskAsync" 
                                                                OnEdit="EditTask" 
                                                                OnAddSubtask="ShowAddSubtaskModal" />
                                }
                                            </div>
                        }

                                <div class="task-group">
                                    <h4 class="font-medium">Tasks</h4>
                            @foreach (var task in regularTasks)
                            {
                                                <TaskItemComponent Task="task" 
                                                    OnComplete="CompleteTaskAsync" 
                                                    OnEdit="EditTask" 
                                                    OnAddSubtask="ShowAddSubtaskModal" />
                            }
                                </div>
                    }
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal container positioned as its own layer outside main layout -->
<div id="task-modals-container">
    @if (showNewTaskModal)
    {
                <div class="task-modal-backdrop"></div>
                <div class="task-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>@(editingTask ? "Edit Task" : "New Task")</h3>
                            <button class="close-button" @onclick="HideModal">×</button>
                        </div>
                        <div class="modal-body">
                            <EditForm Model="newTask" OnValidSubmit="SaveTaskAsync">
                                <DataAnnotationsValidator />
                                <ValidationSummary />

                                <div class="form-group">
                                    <label for="title">Title</label>
                                    <InputText id="title" class="form-input" @bind-Value="newTask.Title" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                                </div>

                                <div class="form-group">
                                    <label for="description">Description</label>
                                    <InputTextArea id="description" class="form-textarea" @bind-Value="newTask.Description" rows="3" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                                </div>

                                <div class="form-row">
                                    <div class="form-group half">
                                        <label for="dueDate">Due Date</label>
                                        <InputDate id="dueDate" class="form-input" @bind-Value="newTask.DueDate" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                                    </div>
                                    <div class="form-group half">
                                        <label for="priority">Priority (1-5)</label>
                                        <InputNumber id="priority" class="form-input" @bind-Value="newTask.Priority" min="1" max="5" @onfocus="async () => await DisableShortcutsAsync()" @onblur="async () => await EnableShortcutsAsync()" />
                                    </div>
                                </div>

                                <div class="form-check">
                                    <InputCheckbox id="isRecurring" @bind-Value="newTask.IsRecurring" />
                                    <label for="isRecurring">Recurring Task</label>
                                </div>

                        @if (newTask.IsRecurring)
                        {
                                            <div class="form-group">
                                                <label for="recurrencePattern">Recurrence Pattern</label>
                                                <InputSelect id="recurrencePattern" class="form-select" @bind-Value="newTask.RecurrencePattern">
                                                    <option value="daily">Daily</option>
                                                    <option value="weekly">Weekly</option>
                                                    <option value="monthly">Monthly</option>
                                                    <option value="yearly">Yearly</option>
                                                    <option value="every 2 days">Every 2 Days</option>
                                                    <option value="every 2 weeks">Every 2 Weeks</option>
                                                </InputSelect>
                                            </div>
                        }

                                <!-- Subtasks Section -->
                                <div class="subtasks-section">
                                    <div class="section-header">
                                        <h4>Subtasks</h4>
                                    </div>

                            @if (newTask.SubTasks.Any())
                            {
                                                <div class="subtasks-list">
                                    @foreach (var subtask in newTask.SubTasks)
                                    {
                                                                <div class="subtask-item">
                                                                    <div class="subtask-checkbox">
                                                                        <input type="checkbox" checked="@subtask.IsCompleted" @onchange="e => subtask.IsCompleted = (bool)e.Value" />
                                                                    </div>
                                                                    <div class="subtask-content">
                                                @subtask.Description
                                                                    </div>
                                                                    <button type="button" class="subtask-remove" @onclick="() => RemoveSubtask(subtask)">×</button>
                                                                </div>
                                    }
                                                </div>
                            }
                            else
                            {
                                                <div class="no-subtasks">No subtasks yet</div>
                            }

                                    <div class="add-subtask-form">
                                        <input type="text" class="form-input" @bind="newSubtaskDescription" placeholder="Add a subtask..." @onkeydown="HandleSubtaskKeyDown" />
                                        <button type="button" class="btn-primary" @onclick="AddSubtaskToCurrentTask">Add</button>
                                    </div>
                                </div>
                                </EditForm>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn-secondary" @onclick="HideModal">Cancel</button>
                            <button type="submit" class="btn-primary" @onclick="SaveTaskAsync">Save</button>
                        </div>
                    </div>
                </div>
    }

    @if (showUserContextModal)
    {
                <div class="task-modal-backdrop"></div>
                <div class="task-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>User Context Settings</h3>
                            <button class="close-button" @onclick="HideModal">×</button>
                        </div>
                        <div class="modal-body">
                            <!-- Work Description -->
                            <div class="form-group context-group">
                                <div class="context-header">
                                    <label for="workDescription">Work Description</label>
                                    <div class="context-pill @GetContextLevelClass(userContext.WorkDescription)">
                                @GetContextLevelText(userContext.WorkDescription)
                                    </div>
                                </div>
                                <textarea id="workDescription" class="form-textarea" 
                                    @bind="userContext.WorkDescription" 
                                    @bind:event="oninput"
                                    @onchange="StateHasChanged"
                                    rows="3" 
                                    placeholder="Describe your work, role, or current project..."></textarea>
                            </div>

                            <!-- Short Term Focus -->
                            <div class="form-group context-group">
                                <div class="context-header">
                                    <label for="shortTermFocus">Short Term Focus</label>
                                    <div class="context-pill @GetContextLevelClass(shortTermFocus)">
                                @GetContextLevelText(shortTermFocus)
                                    </div>
                                </div>
                                <textarea id="shortTermFocus" class="form-textarea" 
                                    @bind="shortTermFocus" 
                                    @bind:event="oninput"
                                    @onchange="StateHasChanged"
                                    rows="3" 
                                    placeholder="What are you focusing on in the short term? E.g., completing project X, learning skill Y..."></textarea>
                            </div>

                            <!-- Long Term Goals -->
                            <div class="form-group context-group">
                                <div class="context-header">
                                    <label for="longTermGoals">Long Term Goals</label>
                                    <div class="context-pill @GetContextLevelClass(longTermGoals)">
                                @GetContextLevelText(longTermGoals)
                                    </div>
                                </div>
                                <textarea id="longTermGoals" class="form-textarea" 
                                    @bind="longTermGoals" 
                                    @bind:event="oninput"
                                    @onchange="StateHasChanged"
                                    rows="3" 
                                    placeholder="What are your long-term goals? E.g., career growth, skill mastery, project completion..."></textarea>
                            </div>

                            <!-- Sorting Preferences -->
                            <div class="form-group">
                                <label>Sorting Preferences</label>
                                <div class="radio-group">
                                    <label class="radio-label">
                                        <input type="radio" name="sortPreference" value="DueDate" 
                                            checked="@(userContext.SortPreference == TaskSortPreference.DueDate)" 
                                            @onchange="() => userContext.SortPreference = TaskSortPreference.DueDate" />
                                        Due Date
                                    </label>
                                    <label class="radio-label">
                                        <input type="radio" name="sortPreference" value="Priority" 
                                            checked="@(userContext.SortPreference == TaskSortPreference.Priority)" 
                                            @onchange="() => userContext.SortPreference = TaskSortPreference.Priority" />
                                        Priority
                                    </label>
                                    <label class="radio-label">
                                        <input type="radio" name="sortPreference" value="CreationDate" 
                                            checked="@(userContext.SortPreference == TaskSortPreference.CreationDate)" 
                                            @onchange="() => userContext.SortPreference = TaskSortPreference.CreationDate" />
                                        Creation Date
                                    </label>
                                </div>
                            </div>

                            <!-- AI Settings -->
                            <div class="form-group">
                                <div class="form-check">
                                    <InputCheckbox id="useReasoning" @bind-Value="userContext.UseReasoning" />
                                    <label for="useReasoning">Use AI reasoning capabilities</label>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" @onclick="HideModal">Cancel</button>
                            <button class="btn-primary" @onclick="SaveUserContext">Save</button>
                        </div>
                    </div>
                </div>
    }

    @if (showSubtaskModal)
    {
                <div class="task-modal-backdrop"></div>
                <div class="task-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Add Subtask</h3>
                            <button class="close-button" @onclick="HideModal">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="subtaskDescription">Description</label>
                                <input id="subtaskDescription" class="form-input" @bind="newSubtaskDescription" />
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" @onclick="HideModal">Cancel</button>
                            <button class="btn-primary" @onclick="AddSubtaskAsync">Add</button>
                        </div>
                    </div>
                </div>
    }

    @if (showSettingsModal)
    {
                <div class="task-modal-backdrop"></div>
                <div class="task-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Settings</h3>
                            <button class="close-button" @onclick="() => showSettingsModal = false">×</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="workDescription">Work Description</label>
                                <textarea id="workDescription" class="form-textarea" @bind="userSettings.WorkDescription" rows="3"></textarea>
                            </div>

                            <div class="form-group">
                                <label>Focus Areas</label>
                                <div class="flex flex-wrap gap-2 mt-2">
                            @foreach (var area in userSettings.FocusAreas)
                            {
                                                <div class="bg-gray-200 px-2 py-1 rounded text-sm flex items-center">
                                                    <span>@area</span>
                                                    <button class="ml-2 text-gray-500" @onclick="() => RemoveFocusArea(area)">×</button>
                                                </div>
                            }
                                    <div class="flex">
                                        <input type="text" class="form-input" @bind="newFocusArea" placeholder="Add focus area..." />
                                        <button class="btn-primary ml-2" @onclick="AddFocusArea">Add</button>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>Preferred AI Model</label>
                                <select class="form-select" @bind="userSettings.PreferredModel">
                                    <option value="qwen32b">Qwen 32B</option>
                                </select>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" @onclick="() => showSettingsModal = false">Cancel</button>
                            <button class="btn-primary" @onclick="SaveSettings">Save</button>
                        </div>
                    </div>
                </div>
    }

    @if (showCompletedTasksModal)
    {
                <div class="task-modal-backdrop"></div>
                <div class="task-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Completed Tasks</h3>
                            <button class="close-button" @onclick="() => showCompletedTasksModal = false">×</button>
                        </div>
                        <div class="modal-body">
                    @if (!completedTasks.Any())
                    {
                                        <div class="empty-state py-8">
                                            <p>No completed tasks yet.</p>
                                        </div>
                    }
                    else
                    {
                                        <div class="completed-tasks-list max-h-96 overflow-y-auto">
                            @foreach (var task in completedTasks)
                            {
                                                        <div class="task-item completed">
                                                            <div class="task-main">
                                                                <div class="task-checkbox">
                                                                    <input type="checkbox" checked disabled />
                                                                </div>
                                                                <div class="task-content">
                                                                    <div class="task-title">@task.Title</div>
                                            @if (!string.IsNullOrEmpty(task.Description))
                                            {
                                                                                <div class="task-description">@task.Description</div>
                                            }
                                                                    <div class="task-metadata">
                                                                        <span>Completed: @task.CreatedDate.ToShortDateString()</span>
                                                                    </div>
                                                                </div>
                                                                <div class="task-actions">
                                                                    <button class="btn btn-sm btn-outline-primary" 
                                                                            title="Reactivate task" 
                                                                            @onclick="() => ReactivateTaskAsync(task)">
                                                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18m-18 0l5-5m-5 5l5 5"></path></svg>
                                                                    </button>
                                                                </div>
                                                            </div>
                                                        </div>
                            }
                                        </div>
                    }
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" @onclick="() => showCompletedTasksModal = false">Close</button>
                        </div>
                    </div>
                </div>
    }

    @if (showRelevantConversations)
    {
                <div class="task-modal-backdrop"></div>
                <div class="task-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Related Past Conversations</h3>
                            <button class="close-button" @onclick="() => showRelevantConversations = false">×</button>
                        </div>
                        <div class="modal-body">
                            <p>I found previous conversations that might be relevant:</p>
                            <div class="conversation-list">
                        @foreach (var conv in relevantConversations)
                        {
                                            <div class="conversation-item">
                                                <div class="conversation-title">@conv.Title</div>
                                                <div class="conversation-date">@conv.CreatedDate.ToShortDateString()</div>
                                                <div class="conversation-summary">@conv.Summary</div>
                                                <div class="conversation-tags">
                                    @foreach (var tag in conv.Tags)
                                    {
                                                                <span class="tag">@tag</span>
                                    }
                                                </div>
                                                <button class="btn-primary" @onclick="() => ReferencePastConversation(conv)">
                                                    Reference This
                                                </button>
                                            </div>
                        }
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn-secondary" @onclick="() => showRelevantConversations = false">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
    }
    @if (showTaskComparisonModal)
    {
        <div class="task-modal-backdrop"></div>
        <div class="task-comparison-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Review Task Changes</h3>
                    <button class="close-button" @onclick="HideModal">×</button>
                </div>
                <div class="modal-body">
                    <div class="comparison-container">
                        <div class="original-task">
                            <h4>Original Task</h4>
                            <div class="comparison-field">
                                <label>Title:</label>
                                <div class="field-value">@originalTask.Title</div>
                            </div>
                            <div class="comparison-field">
                                <label>Description:</label>
                                <div class="field-value">@originalTask.Description</div>
                            </div>
                            <div class="comparison-field">
                                <label>Priority:</label>
                                <div class="field-value">@originalTask.Priority</div>
                            </div>
                            <div class="comparison-field">
                                <label>Due Date:</label>
                                <div class="field-value">@(originalTask.DueDate?.ToShortDateString() ?? "None")</div>
                            </div>
                            <div class="comparison-field">
                                <label>Subtasks:</label>
                                <div class="field-value">
                                    @if (originalTask.SubTasks?.Any() == true)
                                    {
                                            <ul>
                                            @foreach (var subtask in originalTask.SubTasks)
                                            {
                                                        <li>@subtask.Description</li>
                                            }
                                            </ul>
                                    }
                                    else
                                    {
                                            <p>No subtasks</p>
                                    }
                                </div>
                            </div>
                        </div>
                        <div class="edited-task">
                            <h4>Suggested Changes</h4>
                            <div class="comparison-field">
                                <label>Title:</label>
                                <div class="field-value @GetDiffClass(originalTask.Title, editedTask.Title)">@editedTask.Title</div>
                            </div>
                            <div class="comparison-field">
                                <label>Description:</label>
                                <div class="field-value @GetDiffClass(originalTask.Description, editedTask.Description)">@editedTask.Description</div>
                            </div>
                            <div class="comparison-field">
                                <label>Priority:</label>
                                <div class="field-value @GetDiffClass(originalTask.Priority.ToString(), editedTask.Priority.ToString())">@editedTask.Priority</div>
                            </div>
                            <div class="comparison-field">
                                <label>Due Date:</label>
                                <div class="field-value @GetDiffClass(originalTask.DueDate?.ToString(), editedTask.DueDate?.ToString())">
                                    @(editedTask.DueDate?.ToShortDateString() ?? "None")
                                </div>
                            </div>
                            <div class="comparison-field">
                                <label>Subtasks:</label>
                                <div class="field-value">
                                    @if (editedTask.SubTasks?.Any() == true)
                                    {
                                            <ul>
                                            @foreach (var subtask in editedTask.SubTasks)
                                            {
                                                        <li class="@GetSubtaskDiffClass(subtask, originalTask.SubTasks)">@subtask.Description</li>
                                            }
                                            </ul>
                                    }
                                    else
                                    {
                                            <p>No subtasks</p>
                                    }
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-secondary" @onclick="HideModal">Cancel</button>
                    <button class="btn-primary" @onclick="ApplyTaskChanges">Apply Changes</button>
                </div>
            </div>
        </div>
    }
</div>

<style>
    /* Custom styles for task modals that only cover tasks panel */
    #task-modals-container {
        position: relative;
        pointer-events: none; /* Allow clicks to pass through when no modals are visible */
    }

    .task-modal-backdrop {
        position: fixed;
        top: 0;
        left: 60%; /* Start at 60% of screen (after chat panel) */
        width: 40%; /* Only take up the tasks panel width (40% of screen) */
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(5px);
        z-index: 9998;
        display: block;
        pointer-events: all; /* Re-enable pointer events */
    }

.task-modal {
    position: fixed;
    top: 50%;
    left: 80%; /* Center within tasks panel (60% + 40%/2) */
    transform: translateX(-50%) translateY(-50%);
    width: 90%; /* Reduced from 95% to 90% */
    max-width: 700px; /* Reduced from 900px to 700px */
    background-color: #1a1a1a;
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1);
    z-index: 9999;
    max-height: 90vh;
    overflow: hidden; /* This prevents scrollbar on header */
    animation: modal-slide-up 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    display: block;
    pointer-events: all;
}

    /* Keep the original modal styling for content */
    .task-modal .modal-content {
        width: 100%;
        background-color: #1a1a1a;
        display: flex;
        flex-direction: column;
        height: 90vh; /* Match the max-height of the modal */
    }

    .task-modal .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 2rem 3rem;
        background: linear-gradient(to right, #1a1a1a, #252525);
        color: white;
        border-bottom: 2px solid #333;
        position: sticky;
        top: 0;
        z-index: 2;
        flex-shrink: 0; /* Prevent header from shrinking */
    }

    .task-modal .modal-body {
        flex: 1;
        overflow-y: auto; /* Only the body scrolls */
        padding: 2rem 3rem;
    }

    .task-modal .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 1.5rem;
        padding: 2rem 3rem;
        background: linear-gradient(to right, #1a1a1a, #252525);
        border-top: 2px solid #333;
        position: sticky;
        bottom: 0;
        z-index: 2;
        flex-shrink: 0; /* Prevent footer from shrinking */
    }

    
</style>
<style>
    .task-suggestions-dropdown {
        position: absolute;
        background-color: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        max-width: 300px;
        width: auto;
        max-height: 300px;
        overflow-y: auto;
        z-index: 1000;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .task-suggestion-item {
        padding: 0.75rem;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
    }

    .task-suggestion-item:hover {
        background-color: var(--bg-surface);
    }

    .task-suggestion-item .task-title {
        font-weight: 600;
    }

    .task-suggestion-item .task-details {
        font-size: 0.8rem;
        color: var(--text-secondary);
        display: flex;
        gap: 0.75rem;
        margin-top: 0.25rem;
    }
</style>
@code {
    // Task-related properties
    private List<TaskItem> tasks;
    private List<TaskItem> overdueTasks = new List<TaskItem>();
    private List<TaskItem> regularTasks = new List<TaskItem>();
    private TaskItem newTask = new TaskItem();
    private TaskItem currentTask;
    private string newSubtaskDescription;
    private bool loading = true;
    private bool showNewTaskModal = false;
    private bool showSubtaskModal = false;
    private bool editingTask = false;
    private string currentSortOption = "DueDate";

    // Chat-related properties
    private List<ChatMessage> messages = new List<ChatMessage>();
    private List<MessageHistory> conversationHistory = new List<MessageHistory>();
    private string currentMessage = "";
    private bool isStreaming = false;
    private string currentStreamedContent = "";
    private string currentReasoningContent = "";
    private string selectedModel = "qwen32b";
    private bool useReasoning = true;
    private bool showReasoning = true;
    private ElementReference chatMessagesElement;
    private ElementReference textAreaRef;
    private CancellationTokenSource cts = new CancellationTokenSource(); // Initialize here to avoid null reference


    private bool showSettingsModal = false;
    private bool showCompletedTasksModal = false;
    private List<TaskItem> completedTasks = new List<TaskItem>();
    private UserSettings userSettings = new UserSettings();
    private List<TaskSuggestion> extractedTasks = new();
    private string shortTermFocus = ""; // Will store concatenated focus areas
    private string longTermGoals = ""; // Will store concatenated long-term goals

    // For task detection
    private Dictionary<int, TaskDetectionResult> taskSuggestions = new Dictionary<int, TaskDetectionResult>();
    private TaskItem taskFromMessage = new TaskItem();

    private TaskItem taskFromSuggestion = new TaskItem();
    private bool showTaskFromSuggestionModal = false;
    private bool showTaskCreationModal = false;
    private int currentTaskMessageIndex = -1;

    private bool autoScroll = true;
    private bool showScrollButton = false;


    private bool shouldExtractTasks = false;
    private bool showTaskSuggestions = false;
    private List<TaskItem> suggestedTasks = new List<TaskItem>();
    private Dictionary<Guid, TaskItem> mentionedTasks = new Dictionary<Guid, TaskItem>();
    private int mentionStartPos = 0;
    private int mentionCursorPos = 0;
    private double suggestionTop = 0;
    private double suggestionLeft = 0;


    private bool _taskUpdatePending = false;
    private DateTime _lastTaskUpdate = DateTime.MinValue;

    private List<TaskItem> _cachedTasks = null;
    private DateTime _lastTaskCacheTime = DateTime.MinValue;
    // User context setup with proper defaults
    private UserContext userContext = new UserContext
        {
            WorkDescription = "Developing a productivity application",
            FocusAreas = new List<string> { "Task Management", "Note Taking", "AI Integration" },
            LongTermGoals = new List<string> { "Build a seamless productivity system", "Reduce context switching", "Leverage AI for better efficiency" },
            PreferredAIModel = "qwen32b", // Match the default model selection
            UseReasoning = true // Ensure this matches the UI setting
        };

    // Combined lifecycle methods
    protected override async Task OnInitializedAsync()
    {
        // Load existing conversation if any
        var savedHistory = await ConversationService.LoadActiveConversationAsync();

        if (savedHistory != null && savedHistory.Any())
        {
            // Debug output to help diagnose issues
            Console.WriteLine($"Loaded {savedHistory.Count} messages from storage");
            foreach (var msg in savedHistory)
            {
                Console.WriteLine($"Message: {(msg.IsUserMessage ? "User" : "AI")}: {msg.Content.Substring(0, Math.Min(20, msg.Content.Length))}...");
            }

            conversationHistory = savedHistory;

            // Rebuild UI messages from history
            messages = conversationHistory.Select(m => new ChatMessage
                {
                    Content = m.Content,
                    IsFromUser = m.IsUserMessage,
                    ReasoningContent = m.ReasoningContent,
                    HasReasoning = !string.IsNullOrEmpty(m.ReasoningContent)
                }).ToList();

            Console.WriteLine($"Rebuilt {messages.Count} UI messages");
        }
        else
        {
            Console.WriteLine("No saved conversation found or loading failed");
            // Add welcome message if no history
            await InitializeChatWithContextAsync();
        }

        await LoadTasksAsync();
    }
    private List<TaskEditSuggestion> extractedTaskEdits = new();
    private bool showTaskComparisonModal = false;
    private TaskItem originalTask = new();
    private TaskItem editedTask = new();

    // Helper methods for highlighting differences
    private string GetDiffClass(string original, string edited)
    {
        if (string.IsNullOrEmpty(original) && !string.IsNullOrEmpty(edited))
            return "diff-added";
        if (!string.IsNullOrEmpty(original) && string.IsNullOrEmpty(edited))
            return "diff-removed";
        if (original != edited)
            return "diff-changed";
        return "";
    }

    private string GetSubtaskDiffClass(SubTask subtask, List<SubTask> originalSubtasks)
    {
        if (originalSubtasks == null || !originalSubtasks.Any())
            return "diff-added";

        // Check if this subtask exists in the original task
        var originalSubtask = originalSubtasks.FirstOrDefault(s => s.Description == subtask.Description);
        if (originalSubtask == null)
            return "diff-added";

        // If completion status changed
        if (originalSubtask.IsCompleted != subtask.IsCompleted)
            return "diff-changed";

        return "";
    }

    private async Task ShowTaskComparisonModal((TaskItem Original, TaskItem Edited) taskPair)
    {
        originalTask = taskPair.Original;
        editedTask = taskPair.Edited;
        showTaskComparisonModal = true;
        StateHasChanged();
    }

    private async Task ApplyTaskChanges()
    {
        try
        {
            // Preserve the ID from the original task
            editedTask.Id = originalTask.Id;

            // Update the task in the database
            await TaskService.UpdateTaskAsync(editedTask);

            // Add confirmation message to chat
            var confirmation = $"✅ Updated task: \"{editedTask.Title}\"";

            messages.Add(new ChatMessage
                {
                    Content = confirmation,
                    IsFromUser = false,
                    FormattedContent = confirmation
                });

            conversationHistory.Add(new MessageHistory
                {
                    Content = confirmation,
                    IsUserMessage = false,
                    Timestamp = DateTime.Now
                });

            await ConversationService.SaveActiveConversationAsync(conversationHistory);

            // Reload tasks and hide modal
            await LoadTasksAsync();
            showTaskComparisonModal = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error updating task: {ex.Message}");
        }
    }
    private async Task UpdateAIWithLatestTasksAsync()
    {
        // Get all active tasks
        var activeTasks = await TaskService.GetActiveTasksAsync();

        // Format context update message
        var contextBuilder = new StringBuilder();
        contextBuilder.AppendLine("\n[CONTEXT_UPDATE]");
        contextBuilder.AppendLine("## LATEST TASKS");

        if (activeTasks.Any())
        {
            foreach (var task in activeTasks)
            {
                contextBuilder.AppendLine($"- Task: {task.Title}");

                if (!string.IsNullOrEmpty(task.Description))
                    contextBuilder.AppendLine($"  Description: {task.Description}");

                if (task.DueDate.HasValue)
                    contextBuilder.AppendLine($"  Due Date: {task.DueDate.Value:yyyy-MM-dd}");

                contextBuilder.AppendLine($"  Priority: {task.Priority}");

                // Add subtasks if any
                if (task.SubTasks.Any())
                {
                    contextBuilder.AppendLine("  Subtasks:");
                    foreach (var subtask in task.SubTasks)
                    {
                        contextBuilder.AppendLine($"    - {subtask.Description} {(subtask.IsCompleted ? "(Completed)" : "")}");
                    }
                }

                contextBuilder.AppendLine();
            }
        }
        else
        {
            contextBuilder.AppendLine("No active tasks");
        }

        contextBuilder.AppendLine("[/CONTEXT_UPDATE]");

        // Add an invisible system message to conversation history
        var updateMessage = new MessageHistory
            {
                Content = contextBuilder.ToString(),
                IsUserMessage = false,
                Timestamp = DateTime.Now,
                // Flag as a system message (not shown to user)
                IsSystemMessage = true  // You'll need to add this property to MessageHistory class
            };

        conversationHistory.Add(updateMessage);
        await ConversationService.SaveActiveConversationAsync(conversationHistory);

        // Don't add this message to the UI messages list
    }
    private async Task InitializeChatWithContextAsync()
    {
        // Get all active tasks
        var activeTasks = await TaskService.GetActiveTasksAsync();

        // Format welcome message for user display
        var welcomeMessage = "Hello! I'm your ProductivAI assistant. How can I help you today?";

        // Create message for display to user (normal welcome message)
        messages.Add(new ChatMessage
            {
                Content = welcomeMessage,
                IsFromUser = false
            });

        // Format detailed context for AI with task information
        var contextBuilder = new StringBuilder();
        contextBuilder.AppendLine(welcomeMessage);

        // Add invisible section with task data
        contextBuilder.AppendLine("\n[CONTEXT_DATA]");

        // Add user context information
        contextBuilder.AppendLine("\n## USER CONTEXT");
        contextBuilder.AppendLine($"Work Description: {userContext.WorkDescription}");
        contextBuilder.AppendLine($"Focus Areas: {string.Join(", ", userContext.FocusAreas)}");
        contextBuilder.AppendLine($"Long-term Goals: {string.Join(", ", userContext.LongTermGoals)}");
        contextBuilder.AppendLine("\n## TASK CONTEXT UPDATES");
        contextBuilder.AppendLine("You will automatically receive updates when the user's tasks change.");
        contextBuilder.AppendLine("These updates will appear in [TASK_CONTEXT_UPDATE] sections.");
        contextBuilder.AppendLine("When you receive these updates, you should acknowledge them internally and");
        contextBuilder.AppendLine("be aware of the latest task statuses, but don't mention receiving these updates.");

        // Add task information
        contextBuilder.AppendLine("\n## ACTIVE TASKS");

        if (activeTasks.Any())
        {
            foreach (var task in activeTasks)
            {
                // Add basic task info
                contextBuilder.AppendLine($"- Task: {task.Title}");

                if (!string.IsNullOrEmpty(task.Description))
                    contextBuilder.AppendLine($"  Description: {task.Description}");

                if (task.DueDate.HasValue)
                    contextBuilder.AppendLine($"  Due Date: {task.DueDate.Value:yyyy-MM-dd}");

                contextBuilder.AppendLine($"  Priority: {task.Priority}");

                // Add subtasks if any
                if (task.SubTasks.Any())
                {
                    contextBuilder.AppendLine("  Subtasks:");
                    foreach (var subtask in task.SubTasks)
                    {
                        contextBuilder.AppendLine($"    - {subtask.Description} {(subtask.IsCompleted ? "(Completed)" : "")}");
                    }
                }

                contextBuilder.AppendLine();
            }
        }
        else
        {
            contextBuilder.AppendLine("No active tasks");
        }

        contextBuilder.AppendLine("[/CONTEXT_DATA]");

        // Store enhanced context in conversation history (only AI will see this)
        conversationHistory.Add(new MessageHistory
            {
                Content = contextBuilder.ToString(),
                IsUserMessage = false,
                Timestamp = DateTime.Now
            });

        // Save the history with enhanced context
        await ConversationService.SaveActiveConversationAsync(conversationHistory);
    }
    private async Task VerifyConversationHistoryAsync()
    {
        if (conversationHistory == null || conversationHistory.Count == 0)
        {
            Console.WriteLine("Warning: Empty conversation history detected, initializing new conversation");
            await InitializeChatWithContextAsync();
            return;
        }

        // Check if we need to add a summary for a long conversation
        if (conversationHistory.Count > 30) // Increase from 20 to 30
        {
            await AddConversationSummaryAsync();
        }

        // Ensure consistent timestamps
        for (int i = 0; i < conversationHistory.Count; i++)
        {
            if (conversationHistory[i].Timestamp == default)
            {
                conversationHistory[i].Timestamp = DateTime.Now.AddMinutes(-conversationHistory.Count + i);
            }
        }

        Console.WriteLine($"Conversation history verified: {conversationHistory.Count} messages");
    }

    // This method adds a conversation summary
    private async Task AddConversationSummaryAsync()
    {
        try
        {
            // Only summarize if we have an active conversation
            if (conversationHistory.Count < 10) return;

            // Get a summary from the AI service
            string summary = await AIService.GenerateConversationSummaryAsync(conversationHistory);

            if (!string.IsNullOrEmpty(summary))
            {
                // Create a system message with the summary
                var summaryMessage = new MessageHistory
                    {
                        Content = $"[CONVERSATION_SUMMARY] {summary} [/CONVERSATION_SUMMARY]",
                        IsUserMessage = false,
                        IsSystemMessage = true,
                        Timestamp = DateTime.Now
                    };

                // Insert after the welcome message but before other messages
                conversationHistory.Insert(Math.Min(1, conversationHistory.Count), summaryMessage);

                // Save updated conversation history
                await ConversationService.SaveActiveConversationAsync(conversationHistory);

                Console.WriteLine("Added conversation summary to history");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error adding conversation summary: {ex.Message}");
        }
    }
    // Track expanded state for reasoning sections
    private bool expandedReasoning = false;
    private Dictionary<ChatMessage, bool> reasoningExpandedStates = new Dictionary<ChatMessage, bool>();

    private void ToggleReasoningExpansion()
    {
        expandedReasoning = !expandedReasoning;
    }

    private void ToggleMessageReasoningExpansion(ChatMessage message)
    {
        if (!reasoningExpandedStates.ContainsKey(message))
        {
            reasoningExpandedStates[message] = true;
        }
        else
        {
            reasoningExpandedStates[message] = !reasoningExpandedStates[message];
        }
    }
    private void RemoveSubtask(SubTask subtask)
    {
        newTask.SubTasks.Remove(subtask);
    }

    private void AddSubtaskToCurrentTask()
    {
        if (string.IsNullOrWhiteSpace(newSubtaskDescription))
            return;

        newTask.SubTasks.Add(new SubTask
            {
                Description = newSubtaskDescription,
                IsCompleted = false
            });

        newSubtaskDescription = ""; // Clear the input
    }

    private void HandleSubtaskKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(newSubtaskDescription))
        {
            AddSubtaskToCurrentTask();
        }
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Store a reference to this component in JavaScript
            await JSRuntime.InvokeVoidAsync("eval", @"
        document.addEventListener('click', function(e) {
            if (e.target && e.target.classList.contains('task-action-button')) {
                DotNet.invokeMethodAsync('ProductivAI', 'ShowTaskModal');
            }
        });

        // Define the missing setupTaskMentionDetection function
 window.setupTaskMentionDetection = function(textAreaElement, dotNetRef) {
    if (!textAreaElement) return;

    // Debounce function - executes after user stops typing
    let timeout = null;
    let lastSearchTerm = null;
    let mentionActive = false;

    textAreaElement.addEventListener('input', function() {
        // Clear timeout on each keystroke
        clearTimeout(timeout);

        // Set new timeout (250ms delay)
        timeout = setTimeout(() => {
            const cursorPos = this.selectionStart;
            const text = this.value;

            // Just check text around cursor position (20 chars) - not the entire message
            const searchArea = text.substring(Math.max(0, cursorPos - 20), cursorPos);
            const match = searchArea.match(/@([^\s]*)$/);

            if (match) {
                const searchTerm = match[1] || '';

                // Only process if term changed - prevents redundant calls
                if (!mentionActive || searchTerm !== lastSearchTerm) {
                    mentionActive = true;
                    lastSearchTerm = searchTerm;

                    // Calculate exact position only when needed
                    const rect = this.getBoundingClientRect();
                    const fullBeforeCursor = text.substring(0, cursorPos);
                    const atPos = fullBeforeCursor.lastIndexOf('@');

                    dotNetRef.invokeMethodAsync('OnTaskMentionTyped', searchTerm, {
                        top: Math.round(rect.top) + 30,
                        left: Math.round(rect.left) + 20,
                        mentionStart: atPos,
                        cursorPos: cursorPos
                    });
                }
            } else if (mentionActive) {
                mentionActive = false;
                lastSearchTerm = null;
                dotNetRef.invokeMethodAsync('HideTaskSuggestions');
            }
        }, 250); // Adjust delay as needed (250ms is a good balance)
    });
};

        // Define the missing replaceTaskMention function
        window.replaceTaskMention = function(textAreaElement, mentionStart, cursorPos, replacement) {
            if (!textAreaElement) return;

            const text = textAreaElement.value;
            const newText = text.substring(0, mentionStart) + replacement + 
                           text.substring(cursorPos);

            textAreaElement.value = newText;
            textAreaElement.focus();

            const newCursorPos = mentionStart + replacement.length;
            textAreaElement.setSelectionRange(newCursorPos, newCursorPos);
            textAreaElement.dispatchEvent(new Event('input'));
        };

        console.log('Task mention functions defined directly');
    ");

            // Now call the function we just defined
            await JSRuntime.InvokeVoidAsync("setupTaskMentionDetection",
                textAreaRef, DotNetObjectReference.Create(this));

            // Setup scroll handler 
            await JSRuntime.InvokeVoidAsync("setupChatScroll",
                chatMessagesElement,
                DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("fixEscapedHtml");
            // Any other first render initialization...
        }

        foreach (var entry in taskPlaceholders)
        {
            try
            {
                var placeholder = entry.Key;
                var taskData = entry.Value;

                // Get element by ID
                var element = await JSRuntime.InvokeAsync<IJSObjectReference>("document.getElementById", placeholder);

                if (element != null)
                {
                    // Render component into placeholder
                    var componentInstance = new RenderFragment(builder =>
                    {
                        builder.OpenComponent<TaskActionButton>(0);
                        builder.AddAttribute(1, "TaskTitle", taskData.Title);
                        builder.AddAttribute(2, "Description", taskData.Description);
                        builder.AddAttribute(3, "Priority", taskData.Priority);
                        builder.AddAttribute(4, "DueDate", taskData.DueDate);
                        builder.AddAttribute(5, "Subtasks", taskData.Subtasks);
                        builder.AddAttribute(6, "OnTaskCreated", EventCallback.Factory.Create<TaskSuggestion>(this, HandleTaskCreated));
                        builder.CloseComponent();
                    });

                    // Render the component
                    await JSRuntime.InvokeVoidAsync("renderComponent", placeholder, componentInstance);
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error rendering task component: {ex.Message}");
            }
        }
    }


    [JSInvokable]
    public async Task OnTaskMentionTyped(string searchTerm, object position)
    {
        try
        {
            // Skip processing if search term is just 1 character
            if (searchTerm?.Length == 1) return;

            // Get position data
            var positionJson = System.Text.Json.JsonSerializer.Serialize(position);
            using JsonDocument doc = JsonDocument.Parse(positionJson);
            JsonElement root = doc.RootElement;

            // Extract position values (using TryGet to prevent exceptions)
            suggestionTop = root.TryGetProperty("top", out var topElement) ? topElement.GetDouble() : 0;
            suggestionLeft = root.TryGetProperty("left", out var leftElement) ? leftElement.GetDouble() : 0;
            mentionStartPos = root.TryGetProperty("mentionStart", out var startElement) ? startElement.GetInt32() : 0;
            mentionCursorPos = root.TryGetProperty("cursorPos", out var cursorElement) ? cursorElement.GetInt32() : 0;

            // Cache tasks for 30 seconds to avoid frequent DB queries
            if (_cachedTasks == null || (DateTime.Now - _lastTaskCacheTime).TotalSeconds > 30)
            {
                _cachedTasks = (await TaskService.GetActiveTasksAsync()).ToList();
                _lastTaskCacheTime = DateTime.Now;
            }

            // Optimize filtering with cached values and lowercase comparison
            if (string.IsNullOrEmpty(searchTerm))
            {
                // Show all tasks when no search term
                suggestedTasks = _cachedTasks.Take(5).ToList();
            }
            else
            {
                string searchTermLower = searchTerm.ToLowerInvariant();
                suggestedTasks = _cachedTasks
                    .Where(t => t.Title.ToLowerInvariant().Contains(searchTermLower))
                    .Take(5)
                    .ToList();
            }

            showTaskSuggestions = suggestedTasks.Any();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in OnTaskMentionTyped: {ex.Message}");
            showTaskSuggestions = false;
        }

        StateHasChanged();
    }

    [JSInvokable]
    public void HideTaskSuggestions()
    {
        showTaskSuggestions = false;
        StateHasChanged();
    }

    private async Task SelectTask(TaskItem task)
    {
        try
        {
            // Format display text (just the mention, not the full data)
            string displayText = $"@{task.Title}";

            // Replace @mention in textarea
            await JSRuntime.InvokeVoidAsync("replaceTaskMention",
                textAreaRef, mentionStartPos, mentionCursorPos, displayText);

            // Store task for later use
            mentionedTasks[task.Id] = task;

            // Hide suggestions immediately before other operations
            showTaskSuggestions = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error selecting task: {ex.Message}");
        }
    }
    private async Task DisableShortcutsAsync()
    {
        await JSRuntime.InvokeVoidAsync("shortcutsManager.setTypingState", true);
    }

    private async Task EnableShortcutsAsync()
    {
        await JSRuntime.InvokeVoidAsync("shortcutsManager.setTypingState", false);
    }
    public void Dispose()
    {


        // Unsubscribe from events
        TaskService.TasksChanged -= OnTasksChanged;
        cts?.Cancel();
        cts?.Dispose();
    }

    private string newFocusArea = "";

    // User settings class
    private class UserSettings
    {
        public string WorkDescription { get; set; } = "";
        public List<string> FocusAreas { get; set; } = new List<string>();
        public string PreferredModel { get; set; } = "qwen32b";
    }
    private void OnTasksChanged()
    {
        // Set a flag indicating update is needed
        // We'll use debouncing to prevent excessive updates
        _taskUpdatePending = true;

        // Schedule async update
        _ = UpdateTaskContextIfNeededAsync();
    }
    private async Task UpdateTaskContextIfNeededAsync()
    {
        try
        {
            // If no pending update or update was recent (last 10 seconds), skip
            if (!_taskUpdatePending || (DateTime.Now - _lastTaskUpdate).TotalSeconds < 10)
                return;

            // Wait a moment for multiple rapid changes to accumulate
            await Task.Delay(2000);

            // Only proceed if we're still pending
            if (!_taskUpdatePending)
                return;

            // Clear pending flag
            _taskUpdatePending = false;

            // Don't update if chat is not active or streaming
            if (isStreaming || messages.Count <= 1)
                return;

            // Update the time of the last update
            _lastTaskUpdate = DateTime.Now;

            // Create task context update and send to AI
            await CreateAndSendTaskContextUpdateAsync();

            Console.WriteLine("Task context automatically updated");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating task context: {ex.Message}");
        }
    }

    // Add this method to create and send task context
    private async Task CreateAndSendTaskContextUpdateAsync()
    {
        // Get all active tasks
        var activeTasks = await TaskService.GetActiveTasksAsync();

        // Format context update message (invisible to user)
        var contextBuilder = new StringBuilder();
        contextBuilder.AppendLine("\n[TASK_CONTEXT_UPDATE]");

        if (activeTasks.Any())
        {
            contextBuilder.AppendLine($"You now have {activeTasks.Count()} active tasks:");

            foreach (var task in activeTasks)
            {
                // Format as JSON to be consistent with task mentions
                var taskData = new
                {
                    id = task.Id.ToString(),
                    title = task.Title,
                    description = task.Description,
                    dueDate = task.DueDate?.ToString("yyyy-MM-dd"),
                    priority = task.Priority,
                    isCompleted = task.IsCompleted,
                    subtasks = task.SubTasks?.Select(st => new
                    {
                        description = st.Description,
                        isCompleted = st.IsCompleted
                    }).ToList()
                };

                string taskJson = JsonSerializer.Serialize(taskData);
                contextBuilder.AppendLine($"[TASK:{taskJson}]");
            }
        }
        else
        {
            contextBuilder.AppendLine("You have no active tasks.");
        }

        contextBuilder.AppendLine("[/TASK_CONTEXT_UPDATE]");

        // Add as a system message (invisible to user)
        conversationHistory.Add(new MessageHistory
            {
                Content = contextBuilder.ToString(),
                IsUserMessage = false,
                IsSystemMessage = true, // Add this property to MessageHistory class
                Timestamp = DateTime.Now
            });

        // Save updated conversation
        await ConversationService.SaveActiveConversationAsync(conversationHistory);
    }
    // Methods for settings
    private void AddFocusArea()
    {
        if (!string.IsNullOrWhiteSpace(newFocusArea) && !userSettings.FocusAreas.Contains(newFocusArea))
        {
            userSettings.FocusAreas.Add(newFocusArea);
            userContext.FocusAreas.Add(newFocusArea);
            newFocusArea = "";
        }
    }
    private void RemoveFocusArea(string area)
    {
        userSettings.FocusAreas.Remove(area);
        userContext.FocusAreas.Remove(area);
    }

    // ----- TASK MANAGEMENT METHODS -----
    private static Home CurrentInstance;
    protected override void OnInitialized()
    {
        base.OnInitialized();
        CurrentInstance = this;
        TaskService.TasksChanged += OnTasksChanged;

    }
    [JSInvokable]
    public static Task ShowTaskModal()
    {
        // We need a static field to hold a reference to the component instance
        if (CurrentInstance != null)
        {
            CurrentInstance.ShowNewTaskModal(); // Change this to call the instance method
        }
        return Task.CompletedTask;
    }
    [JSInvokable]
    public static Task PrepareTaskModalFromSuggestion()
    {
        Console.WriteLine("PrepareTaskModalFromSuggestion called from JavaScript");
        if (CurrentInstance != null)
        {
            CurrentInstance.ShowTaskModalWithSuggestion();
        }
        else
        {
            Console.WriteLine("Error: CurrentInstance is null");
        }
        return Task.CompletedTask;
    }

    private void ShowTaskModalWithSuggestion()
    {
        Console.WriteLine("ShowTaskModalWithSuggestion called with lastTaskSuggestion: " +
                         (lastTaskSuggestion != null ? lastTaskSuggestion.Title : "null"));

        // Use the last task suggestion if available
        if (lastTaskSuggestion != null)
        {
            // Create a new TaskItem from the suggestion
            newTask = new TaskItem
                {
                    Title = lastTaskSuggestion.Title,
                    Description = lastTaskSuggestion.Description ?? "",
                    Priority = lastTaskSuggestion.Priority,
                    DueDate = lastTaskSuggestion.DueDate,
                    SubTasks = new List<SubTask>(), // Initialize empty list
                    IsRecurring = false,
                    CreatedDate = DateTime.Now
                };

            // Add subtasks if available
            if (lastTaskSuggestion.Subtasks != null)
            {
                foreach (var subtask in lastTaskSuggestion.Subtasks)
                {
                    newTask.SubTasks.Add(new SubTask
                        {
                            Description = subtask,
                            IsCompleted = false,
                            Id = Guid.NewGuid()
                        });
                }
            }
        }
        else
        {
            // If no suggestion data is available, create an empty task
            newTask = new TaskItem
                {
                    Title = "",
                    Description = "",
                    Priority = 3,
                    DueDate = null,
                    SubTasks = new List<SubTask>(),
                    IsRecurring = false
                };
        }

        // Important: Display the modal but don't save the task yet
        editingTask = false;
        showNewTaskModal = true;

        // Force UI refresh
        InvokeAsync(() => StateHasChanged());
    }
    private async Task LoadTasksAsync()
    {
        loading = true;
        StateHasChanged();

        try
        {
            // Get active tasks
            var activeTasks = await TaskService.GetActiveTasksAsync();
            tasks = activeTasks.ToList();

            // Split into overdue and regular tasks
            DateTime today = DateTime.Today;
            overdueTasks = tasks
                .Where(t => t.DueDate.HasValue && t.DueDate.Value < today)
                .ToList();

            regularTasks = tasks
                .Where(t => !t.DueDate.HasValue || t.DueDate.Value >= today)
                .ToList();

            // Apply current sort
            await SortTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error loading tasks: {ex.Message}");
        }
        finally
        {
            loading = false;
            StateHasChanged();
        }
    }

    private async Task SortTasksAsync()
    {
        // Using ProductivAI.Core.Models.TaskSortPreference directly
        var sortPreference = ProductivAI.Core.Models.TaskSortPreference.DueDate;
        Enum.TryParse(currentSortOption, out sortPreference);

        // Sort overdue tasks
        overdueTasks = sortPreference switch
        {
            ProductivAI.Core.Models.TaskSortPreference.DueDate => overdueTasks
                .OrderBy(t => t.DueDate.HasValue ? t.DueDate.Value : DateTime.MaxValue)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.Priority => overdueTasks
                .OrderByDescending(t => t.Priority)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.CreationDate => overdueTasks
                .OrderBy(t => t.CreatedDate)
                .ToList(),
            _ => overdueTasks
        };

        // Sort regular tasks
        regularTasks = sortPreference switch
        {
            ProductivAI.Core.Models.TaskSortPreference.DueDate => regularTasks
                .OrderBy(t => t.DueDate.HasValue ? t.DueDate.Value : DateTime.MaxValue)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.Priority => regularTasks
                .OrderByDescending(t => t.Priority)
                .ToList(),
            ProductivAI.Core.Models.TaskSortPreference.CreationDate => regularTasks
                .OrderBy(t => t.CreatedDate)
                .ToList(),
            _ => regularTasks
        };

        StateHasChanged();
    }
    private string ProcessTaskMarkers(string content)
    {
        if (string.IsNullOrEmpty(content))
            return content;

        // Use regex to find task markers with pattern: [TASK:{...}]
        var regex = new Regex(@"\[TASK:(\{.*?\})\]", RegexOptions.Singleline);
        var matches = regex.Matches(content);

        foreach (Match match in matches)
        {
            try
            {
                // Extract the JSON content
                var json = match.Groups[1].Value;
                var taskData = JsonSerializer.Deserialize<TaskSuggestion>(
                    json,
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
                );

                if (taskData != null)
                {
                    // Store for later use
                    lastTaskSuggestion = taskData;

                    // Create direct HTML replacement
                    var buttonHtml = $@"
<div class=""task-suggestion-block"">
    <p>I've identified a potential task in our conversation:</p>
    <div class=""task-suggestion-content"">
        <h4>{HttpUtility.HtmlEncode(taskData.Title)}</h4>
        <p>Priority: {taskData.Priority}/5</p>
    </div>
    <button class=""task-action-button"" onclick=""window.createTaskFromSuggestion()"">
        View and Create Task
    </button>
</div>";

                    // Replace the task marker with HTML
                    content = content.Replace(match.Value, buttonHtml);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing task marker: {ex.Message}");
            }
        }

        return content;
    }
    private void ShowNewTaskModal()
    {
        // Check if we have a task suggestion to use
        if (lastTaskSuggestion != null)
        {
            newTask = new TaskItem
                {
                    Title = lastTaskSuggestion.Title,
                    Description = lastTaskSuggestion.Description ?? "",
                    Priority = lastTaskSuggestion.Priority,
                    DueDate = lastTaskSuggestion.DueDate
                };

            // Add subtasks if available
            newTask.SubTasks.Clear();
            if (lastTaskSuggestion.Subtasks != null)
            {
                foreach (var subtask in lastTaskSuggestion.Subtasks)
                {
                    newTask.SubTasks.Add(new SubTask
                        {
                            Description = subtask,
                            IsCompleted = false
                        });
                }
            }

            // Clear the suggestion to prevent reuse
            lastTaskSuggestion = null;
        }
        else
        {
            // Create a fresh new task with defaults
            newTask = new TaskItem
                {
                    Title = "",
                    Description = "",
                    Priority = 3,
                    DueDate = null,
                    IsRecurring = false,
                    RecurrencePattern = null,
                    SubTasks = new List<SubTask>()
                };
        }

        // Make sure subtask description is cleared too
        newSubtaskDescription = "";

        editingTask = false;
        showNewTaskModal = true;
        StateHasChanged();
    }
    private void ShowEmptyNewTaskModal()
    {
        // Always create a fresh new task with defaults
        newTask = new TaskItem
            {
                Title = "",
                Description = "",
                Priority = 3,
                DueDate = null,
                IsRecurring = false,
                RecurrencePattern = null,
                SubTasks = new List<SubTask>()
            };

        newSubtaskDescription = "";
        editingTask = false;
        showNewTaskModal = true;
        StateHasChanged();
    }

    private void EditTask(TaskItem task)
    {
        newTask = new TaskItem
            {
                Id = task.Id,
                Title = task.Title,
                Description = task.Description,
                DueDate = task.DueDate,
                Priority = task.Priority,
                IsRecurring = task.IsRecurring,
                RecurrencePattern = task.RecurrencePattern,
                CreatedDate = task.CreatedDate,
                SubTasks = task.SubTasks
            };
        editingTask = true;
        showNewTaskModal = true;
    }

    private void ShowAddSubtaskModal(TaskItem task)
    {
        currentTask = task;
        newSubtaskDescription = string.Empty;
        showSubtaskModal = true;
    }


    private async Task HideModal()
    {
        showNewTaskModal = false;
        showSubtaskModal = false;
        showSettingsModal = false;
        showUserContextModal = false;
        showCompletedTasksModal = false;
        await JSRuntime.InvokeVoidAsync("shortcutsManager.setModalState", false);
        //await EnableShortcutsAsync();
    }

    private async Task SaveTaskAsync()
    {
        try
        {
            if (editingTask)
            {
                await TaskService.UpdateTaskAsync(newTask);
            }
            else
            {
                // Only create task when user clicks Save
                var createdTask = await TaskService.CreateTaskAsync(
                    newTask.Title,
                    newTask.Description,
                    newTask.DueDate,
                    newTask.Priority
                );

                // Add subtasks if any
                if (newTask.SubTasks.Any())
                {
                    foreach (var subtask in newTask.SubTasks)
                    {
                        await TaskService.AddSubTaskAsync(createdTask.Id, subtask.Description);
                    }
                }
            }

            // Clear and hide modal
            HideModal();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error saving task: {ex.Message}");
        }
    }

    private async Task AddSubtaskAsync()
    {
        if (string.IsNullOrWhiteSpace(newSubtaskDescription))
            return;

        try
        {
            await TaskService.AddSubTaskAsync(currentTask.Id, newSubtaskDescription);
            HideModal();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error adding subtask: {ex.Message}");
        }
    }

    private async Task CompleteTaskAsync(TaskItem task)
    {
        try
        {
            await TaskService.CompleteTaskAsync(task.Id);
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error completing task: {ex.Message}");
        }
    }

    // ----- CHAT METHODS -----
    private void PrepareTaskSuggestion(TaskSuggestion suggestion)
    {
        taskFromSuggestion = new TaskItem
            {
                Title = suggestion.Title ?? "New Task",
                Description = suggestion.Description ?? "",
                Priority = suggestion.Priority,
                DueDate = suggestion.DueDate
            };

        taskFromSuggestion.SubTasks.Clear();
        if (suggestion.Subtasks != null)
        {
            foreach (var subtask in suggestion.Subtasks)
            {
                taskFromSuggestion.SubTasks.Add(new SubTask
                    {
                        Description = subtask,
                        IsCompleted = false
                    });
            }
        }
    }
    [JSInvokable]
    public void ShowTaskSuggestionModal()
    {
        newTask = taskFromSuggestion;
        editingTask = false;
        showNewTaskModal = true;
        StateHasChanged();
    }
    public string FormatMessageContentWithoutTaskExtraction(string content)
    {
        if (string.IsNullOrEmpty(content))
            return "";

        // Replace task markers with placeholder text during streaming
        content = Regex.Replace(content, @"\[TASK:(\{.*?\})\]", "[Task suggestion being generated...]");

        // Format content using Markdig
        var pipeline = new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .Build();

        string html = Markdown.ToHtml(content, pipeline);

        // Post-process HTML to clean up spacing
        html = Regex.Replace(html, @"<p>\s*</p>", "");
        html = Regex.Replace(html, @"<br>\s*<br>", "<br>");

        return html;
    }
    private async Task SendMessageAsync()
    {
        var currentDate = DateTime.Now;
        var dateInfo = $"Current date: {currentDate:yyyy-MM-dd}. Today is {currentDate.DayOfWeek}.";

        // Update userContext with this information
        userContext.AdditionalContext = dateInfo;
        if (string.IsNullOrWhiteSpace(currentMessage) || isStreaming)
            return;

        // Original user input for display
        var userInput = currentMessage.Trim();

        // Create a processed version of the input with task data
        string processedInput = userInput;
        await VerifyConversationHistoryAsync();
        // Find task mentions using regex (@TaskName)
        foreach (Match match in Regex.Matches(userInput, @"@([^\s]+)"))
        {
            string mentionText = match.Value;
            string taskTitle = match.Groups[1].Value;

            // Find the mentioned task in our dictionary
            var matchingTask = mentionedTasks.Values
                .FirstOrDefault(t => t.Title.Equals(taskTitle, StringComparison.OrdinalIgnoreCase));

            if (matchingTask != null)
            {
                // Format task data as JSON
                var taskData = new
                {
                    id = matchingTask.Id.ToString(),
                    title = matchingTask.Title,
                    description = matchingTask.Description,
                    dueDate = matchingTask.DueDate?.ToString("yyyy-MM-dd"),
                    priority = matchingTask.Priority,
                    isCompleted = matchingTask.IsCompleted,
                    subTasks = matchingTask.SubTasks?.Select(st => new
                    {
                        description = st.Description,
                        isCompleted = st.IsCompleted
                    }).ToList()
                };

                string taskJson = JsonSerializer.Serialize(taskData);

                // Replace with format that preserves visible mention but adds data for AI
                // The AI will see the JSON data but users only see the @mention
                processedInput = processedInput.Replace(
                    mentionText,
                    $"{mentionText}[TASK:{taskJson}]");
            }
        }

        // Add user message with original content (for display)
        var userMessage = new ChatMessage
            {
                Content = userInput, // Original for display
                IsFromUser = true
            };
        userMessage.FormattedContent = FormatMessageContent(userInput);
        messages.Add(userMessage);

        // Add to conversation history with processed input (includes task data for AI)
        conversationHistory.Add(new MessageHistory
            {
                Content = processedInput, // Enhanced with task data for AI
                IsUserMessage = true,
                Timestamp = DateTime.Now
            });

        // Save after adding user message
        await ConversationService.SaveActiveConversationAsync(conversationHistory);

        // Clear input and update UI
        currentMessage = "";
        StateHasChanged();
        await ScrollToBottomAsync();
        await ResizeTextAreaAsync();

        // Start streaming response
        isStreaming = true;
        currentStreamedContent = "";
        currentReasoningContent = "";

        // Clear any previous task suggestions and task edits while streaming
        extractedTasks.Clear();
        extractedTaskEdits.Clear();

        StateHasChanged();

        // Set up cancellation token
        cts?.Cancel();
        cts = new CancellationTokenSource();

        // Update user context preferences
        userContext.PreferredAIModel = selectedModel;
        userContext.UseReasoning = useReasoning;

        try
        {
            string fullResponseContent = ""; // Store the full content separately for task extraction

            // Process with AI and stream the response
            await AIService.ProcessQueryWithStreamingWithHistoryAsync(
                processedInput,
                userContext,
                conversationHistory,
                async (token, isComplete) =>
                {
                    if (!isComplete)
                    {
                        // Check if this is a reasoning token
                        if (token.Contains("[REASONING]") && token.Contains("[/REASONING]"))
                        {
                            // Extract the reasoning content
                            int startIndex = token.IndexOf("[REASONING]");
                            int endIndex = token.IndexOf("[/REASONING]");
                            string reasoningContent = token.Substring(
                            startIndex + "[REASONING]".Length,
                            endIndex - startIndex - "[REASONING]".Length);

                            // Add to reasoning content
                            currentReasoningContent += reasoningContent;
                        }
                        else
                        {
                            // Regular content token

                            // Add to full content for later task extraction
                            fullResponseContent += token;

                            // For display during streaming, remove task markers
                            string displayToken = Regex.Replace(token, @"\[TASK:(\{.*?\})\]", "");
                            displayToken = Regex.Replace(displayToken, @"\[TASK_EDIT:(\{.*?\})\]", "");
                            currentStreamedContent += displayToken;
                        }

                        await InvokeAsync(StateHasChanged);
                        await InvokeAsync(ScrollToBottomAsync);
                    }
                    else
                    {
                        if (!string.IsNullOrEmpty(fullResponseContent))
                        {
                            // Create message with both content and reasoning
                            var aiMessage = new ChatMessage
                                {
                                    Content = fullResponseContent, // Store the complete content with task markers
                                    IsFromUser = false,
                                    ReasoningContent = currentReasoningContent,
                                    HasReasoning = !string.IsNullOrEmpty(currentReasoningContent)
                                };

                            // Now that streaming is complete, extract tasks and task edits from the full content
                            var (formattedHtml, tasks, taskEdits) = MessageFormatter.FormatMessageWithTaskExtraction(fullResponseContent);
                            aiMessage.FormattedContent = formattedHtml;

                            // Store extracted tasks
                            extractedTasks.Clear();
                            extractedTasks.AddRange(tasks);

                            // Store and process task edits
                            extractedTaskEdits.Clear();
                            extractedTaskEdits.AddRange(taskEdits);

                            // Look up original tasks for each edit suggestion
                            foreach (var editSuggestion in extractedTaskEdits)
                            {
                                if (Guid.TryParse(editSuggestion.OriginalId, out Guid taskId))
                                {
                                    var originalTask = await TaskService.GetTaskByIdAsync(taskId);
                                    if (originalTask != null)
                                    {
                                        editSuggestion.Original = originalTask;
                                    }
                                }
                            }

                            messages.Add(aiMessage);
                            reasoningExpandedStates[aiMessage] = false; // Initially collapsed

                            // Add to conversation history with timestamp
                            var historyMessage = new MessageHistory
                                {
                                    Content = fullResponseContent,
                                    IsUserMessage = false,
                                    ReasoningContent = currentReasoningContent,
                                    Timestamp = DateTime.Now
                                };

                            conversationHistory.Add(historyMessage);

                            // CRITICAL ADDITION: Save conversation after AI response
                            await ConversationService.SaveActiveConversationAsync(conversationHistory);

                            currentStreamedContent = "";
                            currentReasoningContent = "";
                        }

                        // Set streaming to false AFTER processing the content
                        isStreaming = false;
                        await InvokeAsync(StateHasChanged);
                        await InvokeAsync(ScrollToBottomAsync);
                    }
                },
                cts.Token
            );
        }
        catch (Exception ex)
        {
            // Handle error
            isStreaming = false;
            var errorMessage = new ChatMessage
                {
                    Content = $"An error occurred: {ex.Message}",
                    IsFromUser = false,
                    FormattedContent = $"An error occurred: {ex.Message}"
                };

            messages.Add(errorMessage);

            // Add error to conversation history
            conversationHistory.Add(new MessageHistory
                {
                    Content = errorMessage.Content,
                    IsUserMessage = false,
                    Timestamp = DateTime.Now
                });

            // Save conversation even when errors occur
            await ConversationService.SaveActiveConversationAsync(conversationHistory);

            StateHasChanged();
            await ScrollToBottomAsync();
        }
    }
    private void ShowTaskCreationModal(int messageIndex)
    {
        var suggestion = taskSuggestions[messageIndex];
        currentTaskMessageIndex = messageIndex;

        // Create pre-filled task
        taskFromMessage = new TaskItem
            {
                Title = suggestion.SuggestedTitle,
                Description = suggestion.SuggestedDescription,
                Priority = suggestion.SuggestedPriority,
                DueDate = suggestion.SuggestedDueDate
            };

        // Add suggested subtasks
        taskFromMessage.SubTasks.Clear();
        foreach (var subtask in suggestion.SuggestedSubTasks ?? new List<string>())
        {
            taskFromMessage.SubTasks.Add(new SubTask
                {
                    Description = subtask,
                    IsCompleted = false
                });
        }

        showTaskCreationModal = true;
        StateHasChanged();
    }

    private void AddSubtaskToTaskFromMessage()
    {
        if (string.IsNullOrWhiteSpace(newSubtaskDescription))
            return;

        taskFromMessage.SubTasks.Add(new SubTask
            {
                Description = newSubtaskDescription,
                IsCompleted = false
            });

        newSubtaskDescription = "";
    }
    private void ShowTaskModalWithData(TaskSuggestion suggestion)
    {
        // Store the suggestion for use in the modal
        lastTaskSuggestion = suggestion;

        // Show the modal with suggestion data
        ShowTaskModalWithSuggestion();
    }
    private async Task CreateTaskFromMessage()
    {
        try
        {
            // Create the main task
            var createdTask = await TaskService.CreateTaskAsync(
                taskFromMessage.Title,
                taskFromMessage.Description,
                taskFromMessage.DueDate,
                taskFromMessage.Priority
            );

            // Add subtasks
            if (taskFromMessage.SubTasks.Any())
            {
                foreach (var subtask in taskFromMessage.SubTasks)
                {
                    await TaskService.AddSubTaskAsync(createdTask.Id, subtask.Description);
                }
            }

            // Remove the suggestion to prevent duplicate creation
            taskSuggestions.Remove(currentTaskMessageIndex);

            // Add confirmation message to chat
            var confirmation = $"✅ Created task: \"{taskFromMessage.Title}\"";
            if (taskFromMessage.DueDate.HasValue)
            {
                confirmation += $" due {taskFromMessage.DueDate.Value.ToShortDateString()}";
            }

            // Add to conversation
            conversationHistory.Add(new MessageHistory
                {
                    Content = confirmation,
                    IsUserMessage = false,
                    Timestamp = DateTime.Now
                });

            messages.Add(new ChatMessage
                {
                    Content = confirmation,
                    IsFromUser = false
                });

            await ConversationService.SaveActiveConversationAsync(conversationHistory);

            // Close modal
            showTaskCreationModal = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Handle errors
            Console.Error.WriteLine($"Error creating task: {ex.Message}");
        }
    }
    private void SendSuggestedPrompt(string prompt)
    {
        currentMessage = prompt;
        StateHasChanged();
        SendMessageAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey && !string.IsNullOrWhiteSpace(currentMessage) && !isStreaming)
        {

            await SendMessageAsync();
        }
    }

    private void ClearChat()
    {
        messages.Clear();
        conversationHistory.Clear();
        StateHasChanged();
    }



    private async Task ScrollToBottomAsync()
    {
        if (autoScroll)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("scrollToEnd", chatMessagesElement);
            }
            catch
            {
                // Ignore errors if the element isn't rendered yet
            }
        }
    }

    private async Task ForceScrollToBottom()
    {
        autoScroll = true;
        showScrollButton = false;
        await JSRuntime.InvokeVoidAsync("scrollToEnd", chatMessagesElement);
        StateHasChanged();
    }

    private async Task ResizeTextAreaAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("textAreaManager.adjustHeight", textAreaRef);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error resizing: {ex.Message}");
        }
    }
    private string ProcessTaskSuggestions(string content)
    {
        const string taskStartTag = "<task-suggestion>";
        const string taskEndTag = "</task-suggestion>";

        while (content.Contains(taskStartTag))
        {
            int taskStart = content.IndexOf(taskStartTag);
            if (taskStart < 0) break;

            int taskEnd = content.IndexOf(taskEndTag, taskStart);
            if (taskEnd <= taskStart) break;

            try
            {
                // Extract task JSON
                int jsonStart = taskStart + taskStartTag.Length;
                string taskJson = content.Substring(jsonStart, taskEnd - jsonStart).Trim();

                // Parse the task suggestion
                var taskSuggestion = JsonSerializer.Deserialize<TaskSuggestion>(
                    taskJson,
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
                );

                if (taskSuggestion != null)
                {
                    // Create HTML for the task suggestion
                    string taskId = Guid.NewGuid().ToString();
                    string taskHtml = $@"
                <div class=""task-suggestion-block"">
                    <p>I've identified a potential task in our conversation:</p>
                    <div class=""task-suggestion-content"">
                        <h4>{System.Net.WebUtility.HtmlEncode(taskSuggestion.Title)}</h4>
                        <p>Priority: {taskSuggestion.Priority}/5</p>
                    </div>
                    <button class=""task-action-button"" onclick=""window.createTaskFromSuggestion()"">
                        View and Create Task
                    </button>
                </div>";

                    // Store the suggestion for later use
                    lastTaskSuggestion = taskSuggestion;

                    // Replace the task suggestion with our HTML
                    string beforeTask = content.Substring(0, taskStart);
                    string afterTask = content.Substring(taskEnd + taskEndTag.Length);
                    content = beforeTask + taskHtml + afterTask;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error parsing task: {ex.Message}");

                // Remove the problematic tag
                string beforeTask = content.Substring(0, taskStart);
                string afterTask = content.Substring(taskEnd + taskEndTag.Length);
                content = beforeTask + afterTask;
            }
        }

        return content;
    }
    private string FormatMessageContent(string content)
    {
        if (string.IsNullOrEmpty(content))
            return "";

        // During streaming, don't extract tasks
        if (isStreaming)
        {
            return MessageFormatter.FormatMessageContentWithoutTaskExtraction(content);
        }

        // For completed messages, extract tasks and task edits
        var (formattedHtml, tasks, taskEdits) = MessageFormatter.FormatMessageWithTaskExtraction(content);

        return formattedHtml;
    }



    private string ProcessTaskMarkersAfterMarkdown(string html)
    {
        // Find text that matches [TASK:{...}] pattern
        return Regex.Replace(
            html,
            @"\[TASK:(\{.*?\})\]",
            match =>
            {
                try
                {
                    var json = match.Groups[1].Value;
                    var taskData = JsonSerializer.Deserialize<TaskSuggestion>(
                        json,
                        new JsonSerializerOptions
                            {
                                PropertyNameCaseInsensitive = true
                            }
                    );

                    if (taskData != null)
                    {
                        lastTaskSuggestion = taskData;

                        return $@"
                    <div class=""task-suggestion-block"">
                        <p>I've identified a potential task:</p>
                        <div class=""task-suggestion-content"">
                            <h4>{HttpUtility.HtmlEncode(taskData.Title)}</h4>
                            <p>Priority: {taskData.Priority}/5</p>
                        </div>
                        <button class=""task-action-button"" onclick=""window.createTaskFromSuggestion()"">
                            Create Task
                        </button>
                    </div>";
                    }
                    return match.Value;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error processing task marker: {ex.Message}");
                    return match.Value;
                }
            },
            RegexOptions.Singleline
        );
    }
    // Add a dictionary to track task placeholders
    private Dictionary<string, TaskSuggestion> taskPlaceholders = new Dictionary<string, TaskSuggestion>();

    // Add a method to handle task creation from the component
    private async Task HandleTaskCreated(TaskSuggestion suggestion)
    {
        // Create the task
        var task = new TaskItem
            {
                Title = suggestion.Title,
                Description = suggestion.Description,
                Priority = suggestion.Priority,
                DueDate = suggestion.DueDate
            };

        // Create and store new task
        var createdTask = await TaskService.CreateTaskAsync(
            task.Title,
            task.Description,
            task.DueDate,
            task.Priority
        );

        // Add subtasks if available
        if (suggestion.Subtasks?.Any() == true)
        {
            foreach (var subtask in suggestion.Subtasks)
            {
                await TaskService.AddSubTaskAsync(createdTask.Id, subtask);
            }
        }

        // Add confirmation message
        var confirmation = $"✅ Created task: \"{task.Title}\"";

        messages.Add(new ChatMessage
            {
                Content = confirmation,
                IsFromUser = false
            });

        conversationHistory.Add(new MessageHistory
            {
                Content = confirmation,
                IsUserMessage = false,
                Timestamp = DateTime.Now
            });

        await ConversationService.SaveActiveConversationAsync(conversationHistory);

        // Refresh tasks list
        await LoadTasksAsync();
    }
    private string ProcessTaskSuggestionsInHtml(string html)
    {
        const string taskStartTag = "<task-suggestion>";
        const string taskEndTag = "</task-suggestion>";

        while (html.Contains(taskStartTag))
        {
            int taskStart = html.IndexOf(taskStartTag);
            if (taskStart < 0) break;

            int taskEnd = html.IndexOf(taskEndTag, taskStart);
            if (taskEnd <= taskStart) break;

            try
            {
                // Extract the JSON content
                int jsonStart = taskStart + taskStartTag.Length;
                string taskJson = html.Substring(jsonStart, taskEnd - jsonStart).Trim();

                // Parse the task data
                var taskSuggestion = JsonSerializer.Deserialize<TaskSuggestion>(
                    taskJson,
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
                );

                if (taskSuggestion != null)
                {
                    // Store for later use
                    lastTaskSuggestion = taskSuggestion;

                    // Create direct HTML (no markdown processing)
                    string buttonHtml = $@"
                <div class=""task-suggestion-block"">
                    <p>I've identified a potential task in our conversation:</p>
                    <div class=""task-suggestion-content"">
                        <h4>{HttpUtility.HtmlEncode(taskSuggestion.Title)}</h4>
                        <p>Priority: {taskSuggestion.Priority}/5</p>
                    </div>
                    <button class=""task-action-button"" onclick=""window.createTaskFromSuggestion()"">
                        View and Create Task
                    </button>
                </div>";

                    // Replace the tag with our HTML
                    string beforeTask = html.Substring(0, taskStart);
                    string afterTask = html.Substring(taskEnd + taskEndTag.Length);
                    html = beforeTask + buttonHtml + afterTask;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing task suggestion: {ex.Message}");
                string beforeTask = html.Substring(0, taskStart);
                string afterTask = html.Substring(taskEnd + taskEndTag.Length);
                html = beforeTask + afterTask;
            }
        }

        return html;
    }
    private async Task ReactivateTaskAsync(TaskItem task)
    {
        try
        {
            await TaskService.ReactivateTaskAsync(task.Id);
            await LoadCompletedTasksAsync();
            await LoadTasksAsync();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error reactivating task: {ex.Message}");
        }
    }

    private TaskSuggestion lastTaskSuggestion;
    private string lastTaskSuggestionId = Guid.NewGuid().ToString();
    private string ProcessMessageContent(string content)
    {
        if (string.IsNullOrEmpty(content))
            return content;

        // Look for task suggestion blocks
        const string taskStartTag = "<task-suggestion>";
        const string taskEndTag = "</task-suggestion>";

        // Keep processing until all task suggestion tags are handled
        while (content.Contains(taskStartTag))
        {
            int taskStart = content.IndexOf(taskStartTag);
            if (taskStart < 0) break;

            int taskEnd = content.IndexOf(taskEndTag, taskStart);
            if (taskEnd <= taskStart) break;

            try
            {
                // Extract the task JSON
                int jsonStart = taskStart + taskStartTag.Length;
                string taskJson = content.Substring(jsonStart, taskEnd - jsonStart).Trim();

                // Parse the task data
                var taskSuggestion = JsonSerializer.Deserialize<TaskSuggestion>(
                    taskJson,
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
                );

                if (taskSuggestion != null)
                {
                    // Generate a unique ID for this task suggestion
                    string taskId = Guid.NewGuid().ToString();

                    // Store the task data for later use (you need to implement this storage)
                    lastTaskSuggestion = taskSuggestion;
                    lastTaskSuggestionId = taskId;

                    // Create the HTML replacement - use single quotes for attribute values to avoid issues
                    string taskHtml = $@"
<div class=""task-suggestion-block"">
    <p>I've identified a potential task in our conversation:</p>
    <div class=""task-suggestion-content"">
        <h4>{HttpUtility.HtmlEncode(taskSuggestion.Title)}</h4>
        <p>Priority: {taskSuggestion.Priority}/5</p>
    </div>
    <button class=""task-action-button"" onclick=""window.createTaskFromSuggestion()"">
        View and Create Task
    </button>
</div>";

                    // Remove the original tag and insert the HTML
                    string beforeTask = content.Substring(0, taskStart);
                    string afterTask = content.Substring(taskEnd + taskEndTag.Length);
                    content = beforeTask + taskHtml + afterTask;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error parsing task suggestion: {ex.Message}");

                // Remove the invalid task block
                string beforeTask = content.Substring(0, taskStart);
                string afterTask = content.Substring(taskEnd + taskEndTag.Length);
                content = beforeTask + afterTask;
            }
        }

        return content;
    }

    private async Task LoadCompletedTasksAsync()
    {
        try
        {
            var tasks = await TaskService.GetCompletedTasksAsync();
            completedTasks = tasks.ToList();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error loading completed tasks: {ex.Message}");
        }
    }
    private void SaveSettings()
    {
        // Update user context with settings
        userContext.WorkDescription = userSettings.WorkDescription;
        userContext.FocusAreas = new List<string>(userSettings.FocusAreas);
        selectedModel = userSettings.PreferredModel;
        userContext.PreferredAIModel = userSettings.PreferredModel;

        // Close modal
        showSettingsModal = false;
    }

    private bool showUserContextModal = false;
    private string newLongTermGoal = "";

    // Method to show the user context modal
    private void ShowUserContextModal()
    {
        // Convert list items to text for editing
        shortTermFocus = string.Join("\n", userContext.FocusAreas);
        longTermGoals = string.Join("\n", userContext.LongTermGoals);
        showUserContextModal = true;
    }

    private string GetContextLevelClass(string text)
    {
        int wordCount = CountWords(text);

        if (wordCount <= 10)
            return "context-low";
        else if (wordCount <= 30)
            return "context-medium";
        else
            return "context-high";
    }
    private string GetContextLevelText(string text)
    {
        int wordCount = CountWords(text);

        if (wordCount <= 10)
            return "Low Context";
        else if (wordCount <= 30)
            return "Medium Context";
        else
            return "High Context";
    }
    private int CountWords(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return 0;

        return text.Split(new char[] { ' ', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }

    // Methods for handling focus areas

    [JSInvokable]
    public async Task OnChatScroll() // Ensure this name matches what JS is calling
    {
        try
        {
            // Check if user has scrolled up
            var isAtBottom = await JSRuntime.InvokeAsync<bool>("isScrolledToBottom", chatMessagesElement);

            // If not at bottom, show the scroll button and disable auto-scroll
            if (!isAtBottom && !showScrollButton)
            {
                autoScroll = false;
                showScrollButton = true;
                StateHasChanged();
            }
            // If at bottom, hide the button and enable auto-scroll
            else if (isAtBottom && showScrollButton)
            {
                autoScroll = true;
                showScrollButton = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling scroll: {ex.Message}");
        }
    }


    // Methods for handling long-term goals
    private void AddLongTermGoal()
    {
        if (!string.IsNullOrWhiteSpace(newLongTermGoal) && !userContext.LongTermGoals.Contains(newLongTermGoal))
        {
            userContext.LongTermGoals.Add(newLongTermGoal);
            newLongTermGoal = "";
        }
    }

    private void RemoveLongTermGoal(string goal)
    {
        userContext.LongTermGoals.Remove(goal);
    }

    // Method to handle keyboard input (Enter to add tags)
    private void HandleTagKeyDown(KeyboardEventArgs e, Action addAction)
    {
        if (e.Key == "Enter")
        {
            addAction();
        }
    }

    // Method to save user context
    private void SaveUserContext()
    {
        // Convert text areas back to lists
        userContext.FocusAreas = shortTermFocus
            .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => s.Trim())
            .Where(s => !string.IsNullOrWhiteSpace(s))
            .ToList();

        userContext.LongTermGoals = longTermGoals
            .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => s.Trim())
            .Where(s => !string.IsNullOrWhiteSpace(s))
            .ToList();

        // Update related variables
        useReasoning = userContext.UseReasoning;
        currentSortOption = userContext.SortPreference.ToString();

        // Apply sort preference immediately
        SortTasksAsync();

        // Close the modal
        showUserContextModal = false;
    }
    [JSInvokable]
    private async Task HandleChatScroll()
    {
        try
        {
            // Check if user has scrolled up
            var isAtBottom = await JSRuntime.InvokeAsync<bool>("isScrolledToBottom", chatMessagesElement);

            // If not at bottom, show the scroll button and disable auto-scroll
            if (!isAtBottom && !showScrollButton)
            {
                autoScroll = false;
                showScrollButton = true;
                StateHasChanged();
            }
            // If at bottom, hide the button and enable auto-scroll
            else if (isAtBottom && showScrollButton)
            {
                autoScroll = true;
                showScrollButton = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling scroll: {ex.Message}");
        }
    }
    // ----- KEYBOARD SHORTCUT HANDLERS -----

    [JSInvokable]
    public void HandleQuickCreateShortcut()
    {
        ShowNewTaskModal();
        StateHasChanged();
    }

    [JSInvokable]
    public async Task HandleSettingsShortcut()
    {
        // Initialize settings with current user context
        userSettings.WorkDescription = userContext.WorkDescription;
        userSettings.FocusAreas = new List<string>(userContext.FocusAreas);
        userSettings.PreferredModel = selectedModel;

        // Show settings modal
        showSettingsModal = true;
        await DisableShortcutsAsync();
        StateHasChanged();
    }

    [JSInvokable]
    public async Task HandleCompletedTasksShortcut()
    {
        // Load completed tasks
        await LoadCompletedTasksAsync();

        // Show completed tasks modal
        showCompletedTasksModal = true;
        await DisableShortcutsAsync();
        StateHasChanged();
    }

    private bool isEndingConversation = false;
    private List<ConversationSummary> relevantConversations = new List<ConversationSummary>();
    private bool showRelevantConversations = false;
    private async Task EndAndArchiveConversation()
    {
        if (isStreaming || conversationHistory.Count <= 1)
            return;

        isEndingConversation = true;
        StateHasChanged();

        try
        {
            // Use service to generate summary and archive
            var summary = await ConversationService.EndAndArchiveConversationAsync(
                conversationHistory,
                userContext
            );

            // Clear current conversation
            messages.Clear();
            conversationHistory.Clear();

            // Add welcome message
            messages.Add(new ChatMessage
                {
                    Content = $"Previous conversation archived as \"{summary.Title}\".\nHow can I help you today?",
                    IsFromUser = false
                });

            conversationHistory.Add(new MessageHistory
                {
                    Content = $"Previous conversation archived as \"{summary.Title}\".\nHow can I help you today?",
                    IsUserMessage = false
                });

            // Save the new state
            await ConversationService.SaveActiveConversationAsync(conversationHistory);
        }
        catch (Exception ex)
        {
            // Handle error
            Console.Error.WriteLine($"Error archiving conversation: {ex.Message}");
        }
        finally
        {
            isEndingConversation = false;
            StateHasChanged();
        }
    }

    // Add method to check for relevant past conversations
    private async Task CheckForRelevantConversations(string message)
    {
        // Don't check for very short messages
        if (string.IsNullOrWhiteSpace(message) || message.Length < 10)
            return;

        // Get current task ID if focusing on a task
        Guid? currentTaskId = null; // You would set this based on your UI state

        var relevant = await ConversationService.FindRelevantConversationsAsync(message, currentTaskId);

        if (relevant.Any())
        {
            relevantConversations = relevant;
            showRelevantConversations = true;
            StateHasChanged();
        }
    }

    // Add method to reference a past conversation
    private async Task ReferencePastConversation(ConversationSummary conversation)
    {
        // Add reference message to chat
        var referenceMessage = new MessageHistory
            {
                Content = $"From previous conversation about \"{conversation.Title}\" ({conversation.CreatedDate.ToShortDateString()}):\n\n{conversation.Summary}",
                IsUserMessage = false,
                Timestamp = DateTime.Now
            };

        conversationHistory.Insert(1, referenceMessage);

        messages.Insert(1, new ChatMessage
            {
                Content = referenceMessage.Content,
                IsFromUser = false
            });

        await ConversationService.SaveActiveConversationAsync(conversationHistory);
        showRelevantConversations = false;
        StateHasChanged();
    }

    // ----- CLASS DEFINITIONS -----

    private class ChatMessage
    {
        public string Content { get; set; }
        public bool IsFromUser { get; set; }
        public string ReasoningContent { get; set; }
        public bool HasReasoning { get; set; }
        public string FormattedContent { get; set; }
    }

}